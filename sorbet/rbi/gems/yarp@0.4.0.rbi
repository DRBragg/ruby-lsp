# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `yarp` gem.
# Please instead update this file by running `bin/tapioca gem yarp`.

# This file is generated by the bin/template script and should not be
# modified manually. See templates/lib/yarp/node.rb.erb
# if you are looking to modify the template
#
# source://yarp//../../yarp/lib/yarp.rb#3
module YARP
  class << self
    def dump(*_arg0); end
    def dump_file(_arg0); end
    def lex(*_arg0); end

    # Returns an array of tokens that closely resembles that of the Ripper lexer.
    # The only difference is that since we don't keep track of lexer state in the
    # same way, it's going to always return the NONE state.
    #
    # source://yarp//../../yarp/lib/yarp/lex_compat.rb#714
    def lex_compat(source, filepath = T.unsafe(nil)); end

    def lex_file(_arg0); end

    # This lexes with the Ripper lex. It drops any space events but otherwise
    # returns the same tokens. Raises SyntaxError if the syntax in source is
    # invalid.
    #
    # source://yarp//../../yarp/lib/yarp/lex_compat.rb#721
    def lex_ripper(source); end

    # Load the serialized AST using the source as a reference into a tree.
    #
    # source://yarp//../../yarp/lib/yarp.rb#225
    def load(source, serialized); end

    def memsize(_arg0); end
    def named_captures(_arg0); end

    # source://yarp//../../yarp/lib/yarp.rb#229
    def newlines(source); end

    def parse(*_arg0); end
    def parse_file(_arg0); end
    def profile_file(_arg0); end
    def unescape_all(_arg0); end
    def unescape_minimal(_arg0); end
    def unescape_none(_arg0); end
  end
end

# Represents the use of the `alias` keyword.
#
#     alias foo bar
#     ^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#13
class YARP::AliasNode < ::YARP::Node
  # def initialize: (new_name: Node, old_name: Node, keyword_loc: Location, location: Location) -> void
  #
  # @return [AliasNode] a new instance of AliasNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#24
  def initialize(new_name, old_name, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#32
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#37
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#37
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#45
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#50
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#21
  def keyword_loc; end

  # attr_reader new_name: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#15
  def new_name; end

  # attr_reader old_name: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#18
  def old_name; end
end

# Represents an alternation pattern in pattern matching.
#
#     foo => bar | baz
#            ^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#59
class YARP::AlternationPatternNode < ::YARP::Node
  # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [AlternationPatternNode] a new instance of AlternationPatternNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#70
  def initialize(left, right, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#78
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#83
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#83
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#91
  def deconstruct_keys(keys); end

  # attr_reader left: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#61
  def left; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#96
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#67
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#64
  def right; end
end

# Represents the use of the `&&` operator or the `and` keyword.
#
#     left and right
#     ^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#105
class YARP::AndNode < ::YARP::Node
  # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [AndNode] a new instance of AndNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#116
  def initialize(left, right, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#124
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#129
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#129
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#137
  def deconstruct_keys(keys); end

  # attr_reader left: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#107
  def left; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#142
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#113
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#110
  def right; end
end

# Represents a set of arguments to a method or a keyword.
#
#     return foo, bar, baz
#            ^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#151
class YARP::ArgumentsNode < ::YARP::Node
  # def initialize: (arguments: Array[Node], location: Location) -> void
  #
  # @return [ArgumentsNode] a new instance of ArgumentsNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#156
  def initialize(arguments, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#162
  def accept(visitor); end

  # attr_reader arguments: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#153
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#167
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#167
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#175
  def deconstruct_keys(keys); end
end

# Represents an array literal. This can be a regular array using brackets or
# a special array using % like %w or %i.
#
#     [1, 2, 3]
#     ^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#185
class YARP::ArrayNode < ::YARP::Node
  # def initialize: (elements: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [ArrayNode] a new instance of ArrayNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#196
  def initialize(elements, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#204
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#209
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#227
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#193
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#209
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#217
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#187
  def elements; end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#222
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#190
  def opening_loc; end
end

# Represents an array pattern in pattern matching.
#
#     foo in 1, 2
#     ^^^^^^^^^^^
#
#     foo in [1, 2]
#     ^^^^^^^^^^^^^
#
#     foo in *1
#     ^^^^^^^^^
#
#     foo in Bar[]
#     ^^^^^^^^^^^^
#
#     foo in Bar[1, 2, 3]
#     ^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#248
class YARP::ArrayPatternNode < ::YARP::Node
  # def initialize: (constant: Node?, requireds: Array[Node], rest: Node?, posts: Array[Node], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [ArrayPatternNode] a new instance of ArrayPatternNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#268
  def initialize(constant, requireds, rest, posts, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#279
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#284
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#302
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#265
  def closing_loc; end

  # attr_reader constant: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#250
  def constant; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#284
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#292
  def deconstruct_keys(keys); end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#297
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#262
  def opening_loc; end

  # attr_reader posts: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#259
  def posts; end

  # attr_reader requireds: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#253
  def requireds; end

  # attr_reader rest: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#256
  def rest; end
end

# Represents a hash key/value pair.
#
#     { a => b }
#       ^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#311
class YARP::AssocNode < ::YARP::Node
  # def initialize: (key: Node, value: Node?, operator_loc: Location?, location: Location) -> void
  #
  # @return [AssocNode] a new instance of AssocNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#322
  def initialize(key, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#330
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#335
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#335
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#343
  def deconstruct_keys(keys); end

  # attr_reader key: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#313
  def key; end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#348
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#319
  def operator_loc; end

  # attr_reader value: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#316
  def value; end
end

# Represents a splat in a hash literal.
#
#     { **foo }
#       ^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#357
class YARP::AssocSplatNode < ::YARP::Node
  # def initialize: (value: Node?, operator_loc: Location, location: Location) -> void
  #
  # @return [AssocSplatNode] a new instance of AssocSplatNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#365
  def initialize(value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#372
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#377
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#377
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#385
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#390
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#362
  def operator_loc; end

  # attr_reader value: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#359
  def value; end
end

# Represents reading a reference to a field in the previous match.
#
#     $'
#     ^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#399
class YARP::BackReferenceReadNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [BackReferenceReadNode] a new instance of BackReferenceReadNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#401
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#406
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#411
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#411
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#419
  def deconstruct_keys(keys); end
end

# A class that knows how to walk down the tree. None of the individual visit
# methods are implemented on this visitor, so it forces the consumer to
# implement each one that they need. For a default implementation that
# continues walking the tree, see the Visitor class.
#
# source://yarp//../../yarp/lib/yarp/node.rb#6169
class YARP::BasicVisitor
  # source://yarp//../../yarp/lib/yarp/node.rb#6170
  def visit(node); end

  # source://yarp//../../yarp/lib/yarp/node.rb#6174
  def visit_all(nodes); end

  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_child_nodes(node); end
end

# Represents a begin statement.
#
#     begin
#       foo
#     end
#     ^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#430
class YARP::BeginNode < ::YARP::Node
  # def initialize: (begin_keyword_loc: Location?, statements: Node?, rescue_clause: Node?, else_clause: Node?, ensure_clause: Node?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [BeginNode] a new instance of BeginNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#450
  def initialize(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#461
  def accept(visitor); end

  # def begin_keyword: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#479
  def begin_keyword; end

  # attr_reader begin_keyword_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#432
  def begin_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#466
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#466
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#474
  def deconstruct_keys(keys); end

  # attr_reader else_clause: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#441
  def else_clause; end

  # def end_keyword: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#484
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#447
  def end_keyword_loc; end

  # attr_reader ensure_clause: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#444
  def ensure_clause; end

  # attr_reader rescue_clause: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#438
  def rescue_clause; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#435
  def statements; end
end

# Represents block method arguments.
#
#     bar(&args)
#     ^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#493
class YARP::BlockArgumentNode < ::YARP::Node
  # def initialize: (expression: Node?, operator_loc: Location, location: Location) -> void
  #
  # @return [BlockArgumentNode] a new instance of BlockArgumentNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#501
  def initialize(expression, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#508
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#513
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#513
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#521
  def deconstruct_keys(keys); end

  # attr_reader expression: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#495
  def expression; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#526
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#498
  def operator_loc; end
end

# Represents a block of ruby code.
#
# [1, 2, 3].each { |i| puts x }
#                ^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#535
class YARP::BlockNode < ::YARP::Node
  # def initialize: (locals: Array[Symbol], parameters: Node?, statements: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [BlockNode] a new instance of BlockNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#552
  def initialize(locals, parameters, statements, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#562
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#567
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#585
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#549
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#567
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#575
  def deconstruct_keys(keys); end

  # attr_reader locals: Array[Symbol]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#537
  def locals; end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#580
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#546
  def opening_loc; end

  # attr_reader parameters: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#540
  def parameters; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#543
  def statements; end
end

# Represents a block parameter to a method, block, or lambda definition.
#
#     def a(&b)
#           ^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#595
class YARP::BlockParameterNode < ::YARP::Node
  # def initialize: (name_loc: Location?, operator_loc: Location, location: Location) -> void
  #
  # @return [BlockParameterNode] a new instance of BlockParameterNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#603
  def initialize(name_loc, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#610
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#615
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#615
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#623
  def deconstruct_keys(keys); end

  # def name: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#628
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#597
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#633
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#600
  def operator_loc; end
end

# Represents a block's parameters declaration.
#
#     -> (a, b = 1; local) { }
#        ^^^^^^^^^^^^^^^^^
#
#     foo do |a, b = 1; local|
#            ^^^^^^^^^^^^^^^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#646
class YARP::BlockParametersNode < ::YARP::Node
  # def initialize: (parameters: Node?, locals: Array[Location], opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [BlockParametersNode] a new instance of BlockParametersNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#660
  def initialize(parameters, locals, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#669
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#674
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#692
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#657
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#674
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#682
  def deconstruct_keys(keys); end

  # attr_reader locals: Array[Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#651
  def locals; end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#687
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#654
  def opening_loc; end

  # attr_reader parameters: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#648
  def parameters; end
end

# Represents the use of the `break` keyword.
#
#     break foo
#     ^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#701
class YARP::BreakNode < ::YARP::Node
  # def initialize: (arguments: Node?, keyword_loc: Location, location: Location) -> void
  #
  # @return [BreakNode] a new instance of BreakNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#709
  def initialize(arguments, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#716
  def accept(visitor); end

  # attr_reader arguments: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#703
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#721
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#721
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#729
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#734
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#706
  def keyword_loc; end
end

# Represents a method call, in all of the various forms that can take.
#
#     foo
#     ^^^
#
#     foo()
#     ^^^^^
#
#     +foo
#     ^^^^
#
#     foo + bar
#     ^^^^^^^^^
#
#     foo.bar
#     ^^^^^^^
#
#     foo&.bar
#     ^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#758
class YARP::CallNode < ::YARP::Node
  # def initialize: (receiver: Node?, operator_loc: Location?, message_loc: Location?, opening_loc: Location?, arguments: Node?, closing_loc: Location?, block: Node?, flags: Integer, name: String, location: Location) -> void
  #
  # @return [CallNode] a new instance of CallNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#787
  def initialize(receiver, operator_loc, message_loc, opening_loc, arguments, closing_loc, block, flags, name, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#801
  def accept(visitor); end

  # attr_reader arguments: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#772
  def arguments; end

  # attr_reader block: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#778
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#806
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#834
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#775
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#806
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#814
  def deconstruct_keys(keys); end

  # attr_reader flags: Integer
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#781
  def flags; end

  # def message: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#824
  def message; end

  # attr_reader message_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#766
  def message_loc; end

  # attr_reader name: String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#784
  def name; end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#829
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#769
  def opening_loc; end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#819
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#763
  def operator_loc; end

  # attr_reader receiver: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#760
  def receiver; end
end

# source://yarp//../../yarp/lib/yarp/node.rb#6129
module YARP::CallNodeFlags; end

# &. operator
#
# source://yarp//../../yarp/lib/yarp/node.rb#6131
YARP::CallNodeFlags::SAFE_NAVIGATION = T.let(T.unsafe(nil), Integer)

# Represents the use of the `&&=` operator on a call.
#
#     foo.bar &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#843
class YARP::CallOperatorAndWriteNode < ::YARP::Node
  # def initialize: (target: Node, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [CallOperatorAndWriteNode] a new instance of CallOperatorAndWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#854
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#862
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#867
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#867
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#875
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#880
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#848
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#845
  def target; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#851
  def value; end
end

# Represents the use of the `||=` operator on a call.
#
#     foo.bar ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#889
class YARP::CallOperatorOrWriteNode < ::YARP::Node
  # def initialize: (target: Node, value: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [CallOperatorOrWriteNode] a new instance of CallOperatorOrWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#900
  def initialize(target, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#908
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#913
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#913
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#921
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#926
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#897
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#891
  def target; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#894
  def value; end
end

# Represents the use of an assignment operator on a call.
#
#     foo.bar += baz
#     ^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#935
class YARP::CallOperatorWriteNode < ::YARP::Node
  # def initialize: (target: Node, operator_loc: Location, value: Node, operator_id: Symbol, location: Location) -> void
  #
  # @return [CallOperatorWriteNode] a new instance of CallOperatorWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#949
  def initialize(target, operator_loc, value, operator_id, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#958
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#963
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#963
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#971
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#976
  def operator; end

  # attr_reader operator_id: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#946
  def operator_id; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#940
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#937
  def target; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#943
  def value; end
end

# Represents assigning to a local variable in pattern matching.
#
#     foo => [bar => baz]
#            ^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#985
class YARP::CapturePatternNode < ::YARP::Node
  # def initialize: (value: Node, target: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [CapturePatternNode] a new instance of CapturePatternNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#996
  def initialize(value, target, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1004
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1009
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1009
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1017
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1022
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#993
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#990
  def target; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#987
  def value; end
end

# Represents the use of a case statement.
#
# case true
# ^^^^^^^^^
# when false
# end
#
# source://yarp//../../yarp/lib/yarp/node.rb#1033
class YARP::CaseNode < ::YARP::Node
  # def initialize: (predicate: Node?, conditions: Array[Node], consequent: Node?, case_keyword_loc: Location, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [CaseNode] a new instance of CaseNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1050
  def initialize(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1060
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1078
  def case_keyword; end

  # attr_reader case_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1044
  def case_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1065
  def child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1038
  def conditions; end

  # attr_reader consequent: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1041
  def consequent; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1065
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1073
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1083
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1047
  def end_keyword_loc; end

  # attr_reader predicate: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1035
  def predicate; end
end

# Represents a class declaration involving the `class` keyword.
#
#     class Foo end
#     ^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1092
class YARP::ClassNode < ::YARP::Node
  # def initialize: (locals: Array[Symbol], class_keyword_loc: Location, constant_path: Node, inheritance_operator_loc: Location?, superclass: Node?, statements: Node?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [ClassNode] a new instance of ClassNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1115
  def initialize(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, statements, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1127
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1132
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1145
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1097
  def class_keyword_loc; end

  # attr_reader constant_path: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1100
  def constant_path; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1132
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1140
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1155
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1112
  def end_keyword_loc; end

  # def inheritance_operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1150
  def inheritance_operator; end

  # attr_reader inheritance_operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1103
  def inheritance_operator_loc; end

  # attr_reader locals: Array[Symbol]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1094
  def locals; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1109
  def statements; end

  # attr_reader superclass: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1106
  def superclass; end
end

# Represents the use of the `&&=` operator for assignment to a class variable.
#
#     @@target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1164
class YARP::ClassVariableOperatorAndWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ClassVariableOperatorAndWriteNode] a new instance of ClassVariableOperatorAndWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1175
  def initialize(name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1183
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1188
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1188
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1196
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1201
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1166
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1206
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1169
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1172
  def value; end
end

# Represents the use of the `||=` operator for assignment to a class variable.
#
#     @@target ||= value
#     ^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1215
class YARP::ClassVariableOperatorOrWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ClassVariableOperatorOrWriteNode] a new instance of ClassVariableOperatorOrWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1226
  def initialize(name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1234
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1239
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1239
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1247
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1252
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1217
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1257
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1220
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1223
  def value; end
end

# Represents assigning to a class variable using an operator that isn't `=`.
#
#     @@target += value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1266
class YARP::ClassVariableOperatorWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [ClassVariableOperatorWriteNode] a new instance of ClassVariableOperatorWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1280
  def initialize(name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1289
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1294
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1294
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1302
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1307
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1268
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1277
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1271
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1274
  def value; end
end

# Represents referencing a class variable.
#
#     @@foo
#     ^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1316
class YARP::ClassVariableReadNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [ClassVariableReadNode] a new instance of ClassVariableReadNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1318
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1323
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1328
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1328
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1336
  def deconstruct_keys(keys); end
end

# Represents writing to a class variable.
#
#     @@foo = 1
#     ^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1345
class YARP::ClassVariableWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, value: Node?, operator_loc: Location?, location: Location) -> void
  #
  # @return [ClassVariableWriteNode] a new instance of ClassVariableWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1356
  def initialize(name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1364
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1369
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1369
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1377
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1382
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1347
  def name_loc; end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1387
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1353
  def operator_loc; end

  # attr_reader value: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1350
  def value; end
end

# This represents a comment that was encountered during parsing.
#
# source://yarp//../../yarp/lib/yarp.rb#101
class YARP::Comment
  # @return [Comment] a new instance of Comment
  #
  # source://yarp//../../yarp/lib/yarp.rb#104
  def initialize(type, location); end

  # source://yarp//../../yarp/lib/yarp.rb#109
  def deconstruct_keys(keys); end

  # Returns the value of attribute location.
  #
  # source://yarp//../../yarp/lib/yarp.rb#102
  def location; end

  # Returns the value of attribute type.
  #
  # source://yarp//../../yarp/lib/yarp.rb#102
  def type; end
end

# Represents the use of the `&&=` operator for assignment to a constant.
#
#     Target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1396
class YARP::ConstantOperatorAndWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantOperatorAndWriteNode] a new instance of ConstantOperatorAndWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1407
  def initialize(name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1415
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1420
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1420
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1428
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1433
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1398
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1438
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1401
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1404
  def value; end
end

# Represents the use of the `||=` operator for assignment to a constant.
#
#     Target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1447
class YARP::ConstantOperatorOrWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantOperatorOrWriteNode] a new instance of ConstantOperatorOrWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1458
  def initialize(name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1466
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1471
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1471
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1479
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1484
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1449
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1489
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1452
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1455
  def value; end
end

# Represents assigning to a constant using an operator that isn't `=`.
#
#     Target += value
#     ^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1498
class YARP::ConstantOperatorWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [ConstantOperatorWriteNode] a new instance of ConstantOperatorWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1512
  def initialize(name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1521
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1526
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1526
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1534
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1539
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1500
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1509
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1503
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1506
  def value; end
end

# Represents accessing a constant through a path of `::` operators.
#
#     Foo::Bar
#     ^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1548
class YARP::ConstantPathNode < ::YARP::Node
  # def initialize: (parent: Node?, child: Node, delimiter_loc: Location, location: Location) -> void
  #
  # @return [ConstantPathNode] a new instance of ConstantPathNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1559
  def initialize(parent, child, delimiter_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1567
  def accept(visitor); end

  # attr_reader child: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1553
  def child; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1572
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1572
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1580
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1585
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1556
  def delimiter_loc; end

  # attr_reader parent: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1550
  def parent; end
end

# Represents the use of the `&&=` operator for assignment to a constant path.
#
#     Parent::Child &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1594
class YARP::ConstantPathOperatorAndWriteNode < ::YARP::Node
  # def initialize: (target: Node, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantPathOperatorAndWriteNode] a new instance of ConstantPathOperatorAndWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1605
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1613
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1618
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1618
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1626
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1631
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1599
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1596
  def target; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1602
  def value; end
end

# Represents the use of the `||=` operator for assignment to a constant path.
#
#     Parent::Child ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1640
class YARP::ConstantPathOperatorOrWriteNode < ::YARP::Node
  # def initialize: (target: Node, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [ConstantPathOperatorOrWriteNode] a new instance of ConstantPathOperatorOrWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1651
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1659
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1664
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1664
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1672
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1677
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1645
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1642
  def target; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1648
  def value; end
end

# Represents assigning to a constant path using an operator that isn't `=`.
#
#     Parent::Child += value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1686
class YARP::ConstantPathOperatorWriteNode < ::YARP::Node
  # def initialize: (target: Node, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [ConstantPathOperatorWriteNode] a new instance of ConstantPathOperatorWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1700
  def initialize(target, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1709
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1714
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1714
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1722
  def deconstruct_keys(keys); end

  # attr_reader operator: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1697
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1691
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1688
  def target; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1694
  def value; end
end

# Represents writing to a constant.
#
#     Foo = 1
#     ^^^^^^^
#
#     Foo::Bar = 1
#     ^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1734
class YARP::ConstantPathWriteNode < ::YARP::Node
  # def initialize: (target: Node, operator_loc: Location?, value: Node?, location: Location) -> void
  #
  # @return [ConstantPathWriteNode] a new instance of ConstantPathWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1745
  def initialize(target, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1753
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1758
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1758
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1766
  def deconstruct_keys(keys); end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1771
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1739
  def operator_loc; end

  # attr_reader target: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1736
  def target; end

  # attr_reader value: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1742
  def value; end
end

# Represents referencing a constant.
#
#     Foo
#     ^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1780
class YARP::ConstantReadNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [ConstantReadNode] a new instance of ConstantReadNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1782
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1787
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1792
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1792
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1800
  def deconstruct_keys(keys); end
end

# source://yarp//../../yarp/lib/yarp/node.rb#6563
module YARP::DSL
  private

  # Create a new AliasNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6572
  def AliasNode(new_name, old_name, keyword_loc, location = T.unsafe(nil)); end

  # Create a new AlternationPatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6577
  def AlternationPatternNode(left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new AndNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6582
  def AndNode(left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new ArgumentsNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6587
  def ArgumentsNode(arguments, location = T.unsafe(nil)); end

  # Create a new ArrayNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6592
  def ArrayNode(elements, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new ArrayPatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6597
  def ArrayPatternNode(constant, requireds, rest, posts, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new AssocNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6602
  def AssocNode(key, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new AssocSplatNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6607
  def AssocSplatNode(value, operator_loc, location = T.unsafe(nil)); end

  # Create a new BackReferenceReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6612
  def BackReferenceReadNode(location = T.unsafe(nil)); end

  # Create a new BeginNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6617
  def BeginNode(begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new BlockArgumentNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6622
  def BlockArgumentNode(expression, operator_loc, location = T.unsafe(nil)); end

  # Create a new BlockNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6627
  def BlockNode(locals, parameters, statements, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new BlockParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6632
  def BlockParameterNode(name_loc, operator_loc, location = T.unsafe(nil)); end

  # Create a new BlockParametersNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6637
  def BlockParametersNode(parameters, locals, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new BreakNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6642
  def BreakNode(arguments, keyword_loc, location = T.unsafe(nil)); end

  # Create a new CallNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6647
  def CallNode(receiver, operator_loc, message_loc, opening_loc, arguments, closing_loc, block, flags, name, location = T.unsafe(nil)); end

  # Create a new CallOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6652
  def CallOperatorAndWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new CallOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6657
  def CallOperatorOrWriteNode(target, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new CallOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6662
  def CallOperatorWriteNode(target, operator_loc, value, operator_id, location = T.unsafe(nil)); end

  # Create a new CapturePatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6667
  def CapturePatternNode(value, target, operator_loc, location = T.unsafe(nil)); end

  # Create a new CaseNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6672
  def CaseNode(predicate, conditions, consequent, case_keyword_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ClassNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6677
  def ClassNode(locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, statements, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ClassVariableOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6682
  def ClassVariableOperatorAndWriteNode(name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ClassVariableOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6687
  def ClassVariableOperatorOrWriteNode(name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ClassVariableOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6692
  def ClassVariableOperatorWriteNode(name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new ClassVariableReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6697
  def ClassVariableReadNode(location = T.unsafe(nil)); end

  # Create a new ClassVariableWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6702
  def ClassVariableWriteNode(name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new ConstantOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6707
  def ConstantOperatorAndWriteNode(name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6712
  def ConstantOperatorOrWriteNode(name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6717
  def ConstantOperatorWriteNode(name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new ConstantPathNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6722
  def ConstantPathNode(parent, child, delimiter_loc, location = T.unsafe(nil)); end

  # Create a new ConstantPathOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6727
  def ConstantPathOperatorAndWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantPathOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6732
  def ConstantPathOperatorOrWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantPathOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6737
  def ConstantPathOperatorWriteNode(target, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new ConstantPathWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6742
  def ConstantPathWriteNode(target, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new ConstantReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6747
  def ConstantReadNode(location = T.unsafe(nil)); end

  # Create a new DefNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6752
  def DefNode(name_loc, receiver, parameters, statements, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new DefinedNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6757
  def DefinedNode(lparen_loc, value, rparen_loc, keyword_loc, location = T.unsafe(nil)); end

  # Create a new ElseNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6762
  def ElseNode(else_keyword_loc, statements, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new EmbeddedStatementsNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6767
  def EmbeddedStatementsNode(opening_loc, statements, closing_loc, location = T.unsafe(nil)); end

  # Create a new EmbeddedVariableNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6772
  def EmbeddedVariableNode(operator_loc, variable, location = T.unsafe(nil)); end

  # Create a new EnsureNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6777
  def EnsureNode(ensure_keyword_loc, statements, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new FalseNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6782
  def FalseNode(location = T.unsafe(nil)); end

  # Create a new FindPatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6787
  def FindPatternNode(constant, left, requireds, right, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new FloatNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6792
  def FloatNode(location = T.unsafe(nil)); end

  # Create a new ForNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6797
  def ForNode(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ForwardingArgumentsNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6802
  def ForwardingArgumentsNode(location = T.unsafe(nil)); end

  # Create a new ForwardingParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6807
  def ForwardingParameterNode(location = T.unsafe(nil)); end

  # Create a new ForwardingSuperNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6812
  def ForwardingSuperNode(block, location = T.unsafe(nil)); end

  # Create a new GlobalVariableOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6817
  def GlobalVariableOperatorAndWriteNode(name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new GlobalVariableOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6822
  def GlobalVariableOperatorOrWriteNode(name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new GlobalVariableOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6827
  def GlobalVariableOperatorWriteNode(name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new GlobalVariableReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6832
  def GlobalVariableReadNode(location = T.unsafe(nil)); end

  # Create a new GlobalVariableWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6837
  def GlobalVariableWriteNode(name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new HashNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6842
  def HashNode(opening_loc, elements, closing_loc, location = T.unsafe(nil)); end

  # Create a new HashPatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6847
  def HashPatternNode(constant, assocs, kwrest, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new IfNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6852
  def IfNode(if_keyword_loc, predicate, statements, consequent, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new ImaginaryNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6857
  def ImaginaryNode(numeric, location = T.unsafe(nil)); end

  # Create a new InNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6862
  def InNode(pattern, statements, in_loc, then_loc, location = T.unsafe(nil)); end

  # Create a new InstanceVariableOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6867
  def InstanceVariableOperatorAndWriteNode(name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new InstanceVariableOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6872
  def InstanceVariableOperatorOrWriteNode(name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new InstanceVariableOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6877
  def InstanceVariableOperatorWriteNode(name_loc, operator_loc, value, operator, location = T.unsafe(nil)); end

  # Create a new InstanceVariableReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6882
  def InstanceVariableReadNode(location = T.unsafe(nil)); end

  # Create a new InstanceVariableWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6887
  def InstanceVariableWriteNode(name_loc, value, operator_loc, location = T.unsafe(nil)); end

  # Create a new IntegerNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6892
  def IntegerNode(location = T.unsafe(nil)); end

  # Create a new InterpolatedRegularExpressionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6897
  def InterpolatedRegularExpressionNode(opening_loc, parts, closing_loc, flags, location = T.unsafe(nil)); end

  # Create a new InterpolatedStringNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6902
  def InterpolatedStringNode(opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new InterpolatedSymbolNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6907
  def InterpolatedSymbolNode(opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new InterpolatedXStringNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6912
  def InterpolatedXStringNode(opening_loc, parts, closing_loc, location = T.unsafe(nil)); end

  # Create a new KeywordHashNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6917
  def KeywordHashNode(elements, location = T.unsafe(nil)); end

  # Create a new KeywordParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6922
  def KeywordParameterNode(name_loc, value, location = T.unsafe(nil)); end

  # Create a new KeywordRestParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6927
  def KeywordRestParameterNode(operator_loc, name_loc, location = T.unsafe(nil)); end

  # Create a new LambdaNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6932
  def LambdaNode(locals, opening_loc, parameters, statements, location = T.unsafe(nil)); end

  # Create a new LocalVariableOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6937
  def LocalVariableOperatorAndWriteNode(name_loc, operator_loc, value, constant_id, location = T.unsafe(nil)); end

  # Create a new LocalVariableOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6942
  def LocalVariableOperatorOrWriteNode(name_loc, operator_loc, value, constant_id, location = T.unsafe(nil)); end

  # Create a new LocalVariableOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6947
  def LocalVariableOperatorWriteNode(name_loc, operator_loc, value, constant_id, operator_id, location = T.unsafe(nil)); end

  # Create a new LocalVariableReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6952
  def LocalVariableReadNode(constant_id, depth, location = T.unsafe(nil)); end

  # Create a new LocalVariableWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6957
  def LocalVariableWriteNode(constant_id, depth, value, name_loc, operator_loc, location = T.unsafe(nil)); end

  # Create a new Location object
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6567
  def Location(source = T.unsafe(nil), start_offset = T.unsafe(nil), length = T.unsafe(nil)); end

  # Create a new MatchPredicateNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6962
  def MatchPredicateNode(value, pattern, operator_loc, location = T.unsafe(nil)); end

  # Create a new MatchRequiredNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6967
  def MatchRequiredNode(value, pattern, operator_loc, location = T.unsafe(nil)); end

  # Create a new MissingNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6972
  def MissingNode(location = T.unsafe(nil)); end

  # Create a new ModuleNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6977
  def ModuleNode(locals, module_keyword_loc, constant_path, statements, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new MultiWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6982
  def MultiWriteNode(targets, operator_loc, value, lparen_loc, rparen_loc, location = T.unsafe(nil)); end

  # Create a new NextNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6987
  def NextNode(arguments, keyword_loc, location = T.unsafe(nil)); end

  # Create a new NilNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6992
  def NilNode(location = T.unsafe(nil)); end

  # Create a new NoKeywordsParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6997
  def NoKeywordsParameterNode(operator_loc, keyword_loc, location = T.unsafe(nil)); end

  # Create a new NumberedReferenceReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7002
  def NumberedReferenceReadNode(location = T.unsafe(nil)); end

  # Create a new OptionalParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7007
  def OptionalParameterNode(constant_id, name_loc, operator_loc, value, location = T.unsafe(nil)); end

  # Create a new OrNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7012
  def OrNode(left, right, operator_loc, location = T.unsafe(nil)); end

  # Create a new ParametersNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7017
  def ParametersNode(requireds, optionals, posts, rest, keywords, keyword_rest, block, location = T.unsafe(nil)); end

  # Create a new ParenthesesNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7022
  def ParenthesesNode(statements, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new PinnedExpressionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7027
  def PinnedExpressionNode(expression, operator_loc, lparen_loc, rparen_loc, location = T.unsafe(nil)); end

  # Create a new PinnedVariableNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7032
  def PinnedVariableNode(variable, operator_loc, location = T.unsafe(nil)); end

  # Create a new PostExecutionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7037
  def PostExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new PreExecutionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7042
  def PreExecutionNode(statements, keyword_loc, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new ProgramNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7047
  def ProgramNode(locals, statements, location = T.unsafe(nil)); end

  # Create a new RangeNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7052
  def RangeNode(left, right, operator_loc, flags, location = T.unsafe(nil)); end

  # Create a new RationalNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7057
  def RationalNode(numeric, location = T.unsafe(nil)); end

  # Create a new RedoNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7062
  def RedoNode(location = T.unsafe(nil)); end

  # Create a new RegularExpressionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7067
  def RegularExpressionNode(opening_loc, content_loc, closing_loc, unescaped, flags, location = T.unsafe(nil)); end

  # Create a new RequiredDestructuredParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7072
  def RequiredDestructuredParameterNode(parameters, opening_loc, closing_loc, location = T.unsafe(nil)); end

  # Create a new RequiredParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7077
  def RequiredParameterNode(constant_id, location = T.unsafe(nil)); end

  # Create a new RescueModifierNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7082
  def RescueModifierNode(expression, keyword_loc, rescue_expression, location = T.unsafe(nil)); end

  # Create a new RescueNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7087
  def RescueNode(keyword_loc, exceptions, operator_loc, exception, statements, consequent, location = T.unsafe(nil)); end

  # Create a new RestParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7092
  def RestParameterNode(operator_loc, name_loc, location = T.unsafe(nil)); end

  # Create a new RetryNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7097
  def RetryNode(location = T.unsafe(nil)); end

  # Create a new ReturnNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7102
  def ReturnNode(keyword_loc, arguments, location = T.unsafe(nil)); end

  # Create a new SelfNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7107
  def SelfNode(location = T.unsafe(nil)); end

  # Create a new SingletonClassNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7112
  def SingletonClassNode(locals, class_keyword_loc, operator_loc, expression, statements, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new SourceEncodingNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7117
  def SourceEncodingNode(location = T.unsafe(nil)); end

  # Create a new SourceFileNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7122
  def SourceFileNode(filepath, location = T.unsafe(nil)); end

  # Create a new SourceLineNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7127
  def SourceLineNode(location = T.unsafe(nil)); end

  # Create a new SplatNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7132
  def SplatNode(operator_loc, expression, location = T.unsafe(nil)); end

  # Create a new StatementsNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7137
  def StatementsNode(body, location = T.unsafe(nil)); end

  # Create a new StringConcatNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7142
  def StringConcatNode(left, right, location = T.unsafe(nil)); end

  # Create a new StringNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7147
  def StringNode(opening_loc, content_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new SuperNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7152
  def SuperNode(keyword_loc, lparen_loc, arguments, rparen_loc, block, location = T.unsafe(nil)); end

  # Create a new SymbolNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7157
  def SymbolNode(opening_loc, value_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new TrueNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7162
  def TrueNode(location = T.unsafe(nil)); end

  # Create a new UndefNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7167
  def UndefNode(names, keyword_loc, location = T.unsafe(nil)); end

  # Create a new UnlessNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7172
  def UnlessNode(keyword_loc, predicate, statements, consequent, end_keyword_loc, location = T.unsafe(nil)); end

  # Create a new UntilNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7177
  def UntilNode(keyword_loc, predicate, statements, location = T.unsafe(nil)); end

  # Create a new WhenNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7182
  def WhenNode(keyword_loc, conditions, statements, location = T.unsafe(nil)); end

  # Create a new WhileNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7187
  def WhileNode(keyword_loc, predicate, statements, location = T.unsafe(nil)); end

  # Create a new XStringNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7192
  def XStringNode(opening_loc, content_loc, closing_loc, unescaped, location = T.unsafe(nil)); end

  # Create a new YieldNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#7197
  def YieldNode(keyword_loc, lparen_loc, arguments, rparen_loc, location = T.unsafe(nil)); end
end

# Represents a method definition.
#
#     def method
#     end
#     ^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1810
class YARP::DefNode < ::YARP::Node
  # def initialize: (name_loc: Location, receiver: Node?, parameters: Node?, statements: Node?, locals: Array[Symbol], def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [DefNode] a new instance of DefNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1845
  def initialize(name_loc, receiver, parameters, statements, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1861
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1866
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1866
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1874
  def deconstruct_keys(keys); end

  # def def_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1884
  def def_keyword; end

  # attr_reader def_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1827
  def def_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1909
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1842
  def end_keyword_loc; end

  # def equal: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1904
  def equal; end

  # attr_reader equal_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1839
  def equal_loc; end

  # attr_reader locals: Array[Symbol]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1824
  def locals; end

  # def lparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1894
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1833
  def lparen_loc; end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1879
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1812
  def name_loc; end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1889
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1830
  def operator_loc; end

  # attr_reader parameters: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1818
  def parameters; end

  # attr_reader receiver: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1815
  def receiver; end

  # def rparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1899
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1836
  def rparen_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1821
  def statements; end
end

# Represents the use of the `defined?` keyword.
#
#     defined?(a)
#     ^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1918
class YARP::DefinedNode < ::YARP::Node
  # def initialize: (lparen_loc: Location?, value: Node, rparen_loc: Location?, keyword_loc: Location, location: Location) -> void
  #
  # @return [DefinedNode] a new instance of DefinedNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1932
  def initialize(lparen_loc, value, rparen_loc, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1941
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1946
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1946
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1954
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1969
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1929
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1959
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1920
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1964
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1926
  def rparen_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1923
  def value; end
end

# Represents an `else` clause in a `case`, `if`, or `unless` statement.
#
#     if a then b else c end
#                 ^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#1978
class YARP::ElseNode < ::YARP::Node
  # def initialize: (else_keyword_loc: Location, statements: Node?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [ElseNode] a new instance of ElseNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1989
  def initialize(else_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1997
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2002
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2002
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2010
  def deconstruct_keys(keys); end

  # def else_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2015
  def else_keyword; end

  # attr_reader else_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1980
  def else_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2020
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1986
  def end_keyword_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#1983
  def statements; end
end

# Represents an interpolated set of statements.
#
#     "foo #{bar}"
#          ^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2029
class YARP::EmbeddedStatementsNode < ::YARP::Node
  # def initialize: (opening_loc: Location, statements: Node?, closing_loc: Location, location: Location) -> void
  #
  # @return [EmbeddedStatementsNode] a new instance of EmbeddedStatementsNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2040
  def initialize(opening_loc, statements, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2048
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2053
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2071
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2037
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2053
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2061
  def deconstruct_keys(keys); end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2066
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2031
  def opening_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2034
  def statements; end
end

# Represents an interpolated variable.
#
#     "foo #@bar"
#          ^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2080
class YARP::EmbeddedVariableNode < ::YARP::Node
  # def initialize: (operator_loc: Location, variable: Node, location: Location) -> void
  #
  # @return [EmbeddedVariableNode] a new instance of EmbeddedVariableNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2088
  def initialize(operator_loc, variable, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2095
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2100
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2100
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2108
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2113
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2082
  def operator_loc; end

  # attr_reader variable: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2085
  def variable; end
end

# Represents an `ensure` clause in a `begin` statement.
#
#     begin
#       foo
#     ensure
#     ^^^^^^
#       bar
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#2126
class YARP::EnsureNode < ::YARP::Node
  # def initialize: (ensure_keyword_loc: Location, statements: Node?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [EnsureNode] a new instance of EnsureNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2137
  def initialize(ensure_keyword_loc, statements, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2145
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2150
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2150
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2158
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2168
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2134
  def end_keyword_loc; end

  # def ensure_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2163
  def ensure_keyword; end

  # attr_reader ensure_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2128
  def ensure_keyword_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2131
  def statements; end
end

# Represents the use of the literal `false` keyword.
#
#     false
#     ^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2177
class YARP::FalseNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [FalseNode] a new instance of FalseNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2179
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2184
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2189
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2189
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2197
  def deconstruct_keys(keys); end
end

# Represents a find pattern in pattern matching.
#
#     foo in *bar, baz, *qux
#     ^^^^^^^^^^^^^^^^^^^^^^
#
#     foo in [*bar, baz, *qux]
#     ^^^^^^^^^^^^^^^^^^^^^^^^
#
#     foo in Foo(*bar, baz, *qux)
#     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2212
class YARP::FindPatternNode < ::YARP::Node
  # def initialize: (constant: Node?, left: Node, requireds: Array[Node], right: Node, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [FindPatternNode] a new instance of FindPatternNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2232
  def initialize(constant, left, requireds, right, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2243
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2248
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2266
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2229
  def closing_loc; end

  # attr_reader constant: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2214
  def constant; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2248
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2256
  def deconstruct_keys(keys); end

  # attr_reader left: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2217
  def left; end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2261
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2226
  def opening_loc; end

  # attr_reader requireds: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2220
  def requireds; end

  # attr_reader right: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2223
  def right; end
end

# Represents a floating point number literal.
#
#     1.0
#     ^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2275
class YARP::FloatNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [FloatNode] a new instance of FloatNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2277
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2282
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2287
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2287
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2295
  def deconstruct_keys(keys); end
end

# Represents the use of the `for` keyword.
#
#     for i in a end
#     ^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2304
class YARP::ForNode < ::YARP::Node
  # def initialize: (index: Node, collection: Node, statements: Node?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [ForNode] a new instance of ForNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2327
  def initialize(index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2339
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2344
  def child_nodes; end

  # attr_reader collection: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2309
  def collection; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2344
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2352
  def deconstruct_keys(keys); end

  # def do_keyword: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2367
  def do_keyword; end

  # attr_reader do_keyword_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2321
  def do_keyword_loc; end

  # def end_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2372
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2324
  def end_keyword_loc; end

  # def for_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2357
  def for_keyword; end

  # attr_reader for_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2315
  def for_keyword_loc; end

  # def in_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2362
  def in_keyword; end

  # attr_reader in_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2318
  def in_keyword_loc; end

  # attr_reader index: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2306
  def index; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2312
  def statements; end
end

# Represents forwarding all arguments to this method to another method.
#
#     def foo(...)
#       bar(...)
#       ^^^^^^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#2383
class YARP::ForwardingArgumentsNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [ForwardingArgumentsNode] a new instance of ForwardingArgumentsNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2385
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2390
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2395
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2395
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2403
  def deconstruct_keys(keys); end
end

# Represents the use of the forwarding parameter in a method, block, or lambda declaration.
#
#     def foo(...)
#             ^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#2413
class YARP::ForwardingParameterNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [ForwardingParameterNode] a new instance of ForwardingParameterNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2415
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2420
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2425
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2425
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2433
  def deconstruct_keys(keys); end
end

# Represents the use of the `super` keyword without parentheses or arguments.
#
#     super
#     ^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2442
class YARP::ForwardingSuperNode < ::YARP::Node
  # def initialize: (block: Node?, location: Location) -> void
  #
  # @return [ForwardingSuperNode] a new instance of ForwardingSuperNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2447
  def initialize(block, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2453
  def accept(visitor); end

  # attr_reader block: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2444
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2458
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2458
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2466
  def deconstruct_keys(keys); end
end

# Represents the use of the `&&=` operator for assignment to a global variable.
#
#     $target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2475
class YARP::GlobalVariableOperatorAndWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [GlobalVariableOperatorAndWriteNode] a new instance of GlobalVariableOperatorAndWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2486
  def initialize(name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2494
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2499
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2499
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2507
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2512
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2477
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2517
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2480
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2483
  def value; end
end

# Represents the use of the `||=` operator for assignment to a global variable.
#
#     $target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2526
class YARP::GlobalVariableOperatorOrWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [GlobalVariableOperatorOrWriteNode] a new instance of GlobalVariableOperatorOrWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2537
  def initialize(name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2545
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2550
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2550
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2558
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2563
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2528
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2568
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2531
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2534
  def value; end
end

# Represents assigning to a global variable using an operator that isn't `=`.
#
#     $target += value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2577
class YARP::GlobalVariableOperatorWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [GlobalVariableOperatorWriteNode] a new instance of GlobalVariableOperatorWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2591
  def initialize(name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2600
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2605
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2605
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2613
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2618
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2579
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2588
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2582
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2585
  def value; end
end

# Represents referencing a global variable.
#
#     $foo
#     ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2627
class YARP::GlobalVariableReadNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [GlobalVariableReadNode] a new instance of GlobalVariableReadNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2629
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2634
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2639
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2639
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2647
  def deconstruct_keys(keys); end
end

# Represents writing to a global variable.
#
#     $foo = 1
#     ^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2656
class YARP::GlobalVariableWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location?, value: Node?, location: Location) -> void
  #
  # @return [GlobalVariableWriteNode] a new instance of GlobalVariableWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2667
  def initialize(name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2675
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2680
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2680
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2688
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2693
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2658
  def name_loc; end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2698
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2661
  def operator_loc; end

  # attr_reader value: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2664
  def value; end
end

# Represents a hash literal.
#
#     { a => b }
#     ^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2707
class YARP::HashNode < ::YARP::Node
  # def initialize: (opening_loc: Location, elements: Array[Node], closing_loc: Location, location: Location) -> void
  #
  # @return [HashNode] a new instance of HashNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2718
  def initialize(opening_loc, elements, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2726
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2731
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2749
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2715
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2731
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2739
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2712
  def elements; end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2744
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2709
  def opening_loc; end
end

# Represents a hash pattern in pattern matching.
#
#     foo => { a: 1, b: 2 }
#            ^^^^^^^^^^^^^^
#
#     foo => { a: 1, b: 2, **c }
#            ^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2761
class YARP::HashPatternNode < ::YARP::Node
  # def initialize: (constant: Node?, assocs: Array[Node], kwrest: Node?, opening_loc: Location?, closing_loc: Location?, location: Location) -> void
  #
  # @return [HashPatternNode] a new instance of HashPatternNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2778
  def initialize(constant, assocs, kwrest, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2788
  def accept(visitor); end

  # attr_reader assocs: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2766
  def assocs; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2793
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2811
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2775
  def closing_loc; end

  # attr_reader constant: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2763
  def constant; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2793
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2801
  def deconstruct_keys(keys); end

  # attr_reader kwrest: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2769
  def kwrest; end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2806
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2772
  def opening_loc; end
end

# Represents the use of the `if` keyword, either in the block form or the modifier form.
#
#     bar if foo
#     ^^^^^^^^^^
#
#     if foo then bar end
#     ^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2823
class YARP::IfNode < ::YARP::Node
  # def initialize: (if_keyword_loc: Location?, predicate: Node, statements: Node?, consequent: Node?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [IfNode] a new instance of IfNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2840
  def initialize(if_keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2850
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2855
  def child_nodes; end

  # attr_reader consequent: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2834
  def consequent; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2855
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2863
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2873
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2837
  def end_keyword_loc; end

  # def if_keyword: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2868
  def if_keyword; end

  # attr_reader if_keyword_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2825
  def if_keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2828
  def predicate; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2831
  def statements; end
end

# Represents an imaginary number literal.
#
#     1.0i
#     ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2882
class YARP::ImaginaryNode < ::YARP::Node
  # def initialize: (numeric: Node, location: Location) -> void
  #
  # @return [ImaginaryNode] a new instance of ImaginaryNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2887
  def initialize(numeric, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2893
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2898
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2898
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2906
  def deconstruct_keys(keys); end

  # attr_reader numeric: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2884
  def numeric; end
end

# Represents the use of the `in` keyword in a case statement.
#
#     case a; in b then c end
#             ^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2915
class YARP::InNode < ::YARP::Node
  # def initialize: (pattern: Node, statements: Node?, in_loc: Location, then_loc: Location?, location: Location) -> void
  #
  # @return [InNode] a new instance of InNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2929
  def initialize(pattern, statements, in_loc, then_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2938
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2943
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2943
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2951
  def deconstruct_keys(keys); end

  # def in: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2956
  def in; end

  # attr_reader in_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2923
  def in_loc; end

  # attr_reader pattern: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2917
  def pattern; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2920
  def statements; end

  # def then: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2961
  def then; end

  # attr_reader then_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2926
  def then_loc; end
end

# Represents the use of the `&&=` operator for assignment to an instance variable.
#
#     @target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#2970
class YARP::InstanceVariableOperatorAndWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [InstanceVariableOperatorAndWriteNode] a new instance of InstanceVariableOperatorAndWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2981
  def initialize(name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2989
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2994
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2994
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3002
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3007
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2972
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3012
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2975
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#2978
  def value; end
end

# Represents the use of the `||=` operator for assignment to an instance variable.
#
#     @target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3021
class YARP::InstanceVariableOperatorOrWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [InstanceVariableOperatorOrWriteNode] a new instance of InstanceVariableOperatorOrWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3032
  def initialize(name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3040
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3045
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3045
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3053
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3058
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3023
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3063
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3026
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3029
  def value; end
end

# Represents assigning to an instance variable using an operator that isn't `=`.
#
#     @target += value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3072
class YARP::InstanceVariableOperatorWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, operator: Symbol, location: Location) -> void
  #
  # @return [InstanceVariableOperatorWriteNode] a new instance of InstanceVariableOperatorWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3086
  def initialize(name_loc, operator_loc, value, operator, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3095
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3100
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3100
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3108
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3113
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3074
  def name_loc; end

  # attr_reader operator: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3083
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3077
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3080
  def value; end
end

# Represents referencing an instance variable.
#
#     @foo
#     ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3122
class YARP::InstanceVariableReadNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [InstanceVariableReadNode] a new instance of InstanceVariableReadNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3124
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3129
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3134
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3134
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3142
  def deconstruct_keys(keys); end
end

# Represents writing to an instance variable.
#
#     @foo = 1
#     ^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3151
class YARP::InstanceVariableWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, value: Node?, operator_loc: Location?, location: Location) -> void
  #
  # @return [InstanceVariableWriteNode] a new instance of InstanceVariableWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3162
  def initialize(name_loc, value, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3170
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3175
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3175
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3183
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3188
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3153
  def name_loc; end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3193
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3159
  def operator_loc; end

  # attr_reader value: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3156
  def value; end
end

# Represents an integer number literal.
#
#     1
#     ^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3202
class YARP::IntegerNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [IntegerNode] a new instance of IntegerNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3204
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3209
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3214
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3214
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3222
  def deconstruct_keys(keys); end
end

# Represents a regular expression literal that contains interpolation.
#
#     /foo #{bar} baz/
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3231
class YARP::InterpolatedRegularExpressionNode < ::YARP::Node
  # def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [InterpolatedRegularExpressionNode] a new instance of InterpolatedRegularExpressionNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3245
  def initialize(opening_loc, parts, closing_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3254
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3259
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3277
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3239
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3259
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3267
  def deconstruct_keys(keys); end

  # attr_reader flags: Integer
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3242
  def flags; end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3272
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3233
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3236
  def parts; end
end

# Represents a string literal that contains interpolation.
#
#     "foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3286
class YARP::InterpolatedStringNode < ::YARP::Node
  # def initialize: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> void
  #
  # @return [InterpolatedStringNode] a new instance of InterpolatedStringNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3297
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3305
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3310
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3328
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3294
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3310
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3318
  def deconstruct_keys(keys); end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3323
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3288
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3291
  def parts; end
end

# Represents a symbol literal that contains interpolation.
#
#     :"foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3337
class YARP::InterpolatedSymbolNode < ::YARP::Node
  # def initialize: (opening_loc: Location?, parts: Array[Node], closing_loc: Location?, location: Location) -> void
  #
  # @return [InterpolatedSymbolNode] a new instance of InterpolatedSymbolNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3348
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3356
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3361
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3379
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3345
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3361
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3369
  def deconstruct_keys(keys); end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3374
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3339
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3342
  def parts; end
end

# Represents an xstring literal that contains interpolation.
#
#     `foo #{bar} baz`
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3388
class YARP::InterpolatedXStringNode < ::YARP::Node
  # def initialize: (opening_loc: Location, parts: Array[Node], closing_loc: Location, location: Location) -> void
  #
  # @return [InterpolatedXStringNode] a new instance of InterpolatedXStringNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3399
  def initialize(opening_loc, parts, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3407
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3412
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3430
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3396
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3412
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3420
  def deconstruct_keys(keys); end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3425
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3390
  def opening_loc; end

  # attr_reader parts: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3393
  def parts; end
end

# Represents a hash literal without opening and closing braces.
#
#     foo(a: b)
#         ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3439
class YARP::KeywordHashNode < ::YARP::Node
  # def initialize: (elements: Array[Node], location: Location) -> void
  #
  # @return [KeywordHashNode] a new instance of KeywordHashNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3444
  def initialize(elements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3450
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3455
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3455
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3463
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3441
  def elements; end
end

# Represents a keyword parameter to a method, block, or lambda definition.
#
#     def a(b:)
#           ^^
#     end
#
#     def a(b: 1)
#           ^^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#3477
class YARP::KeywordParameterNode < ::YARP::Node
  # def initialize: (name_loc: Location, value: Node?, location: Location) -> void
  #
  # @return [KeywordParameterNode] a new instance of KeywordParameterNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3485
  def initialize(name_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3492
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3497
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3497
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3505
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3510
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3479
  def name_loc; end

  # attr_reader value: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3482
  def value; end
end

# Represents a keyword rest parameter to a method, block, or lambda definition.
#
#     def a(**b)
#           ^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#3520
class YARP::KeywordRestParameterNode < ::YARP::Node
  # def initialize: (operator_loc: Location, name_loc: Location?, location: Location) -> void
  #
  # @return [KeywordRestParameterNode] a new instance of KeywordRestParameterNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3528
  def initialize(operator_loc, name_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3535
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3540
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3540
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3548
  def deconstruct_keys(keys); end

  # def name: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3558
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3525
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3553
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3522
  def operator_loc; end
end

# Represents using a lambda literal (not the lambda method call).
#
#     ->(value) { value * 2 }
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3567
class YARP::LambdaNode < ::YARP::Node
  # def initialize: (locals: Array[Symbol], opening_loc: Location, parameters: Node?, statements: Node?, location: Location) -> void
  #
  # @return [LambdaNode] a new instance of LambdaNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3581
  def initialize(locals, opening_loc, parameters, statements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3590
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3595
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3595
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3603
  def deconstruct_keys(keys); end

  # attr_reader locals: Array[Symbol]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3569
  def locals; end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3608
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3572
  def opening_loc; end

  # attr_reader parameters: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3575
  def parameters; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3578
  def statements; end
end

# This class is responsible for lexing the source using YARP and then
# converting those tokens to be compatible with Ripper. In the vast majority
# of cases, this is a one-to-one mapping of the token type. Everything else
# generally lines up. However, there are a few cases that require special
# handling.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#11
class YARP::LexCompat
  # @return [LexCompat] a new instance of LexCompat
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#539
  def initialize(source, filepath = T.unsafe(nil)); end

  # Returns the value of attribute filepath.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#537
  def filepath; end

  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#544
  def result; end

  # Returns the value of attribute source.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#537
  def source; end
end

# It is extremely non obvious which state the parser is in when comments get
# dispatched. Because of this we don't both comparing state when comparing
# against other comment tokens.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#207
class YARP::LexCompat::CommentToken < ::YARP::LexCompat::Token
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#208
  def ==(other); end
end

# Ripper doesn't include the rest of the token in the event, so we need to
# trim it down to just the content on the first line when comparing.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#198
class YARP::LexCompat::EndContentToken < ::YARP::LexCompat::Token
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#199
  def ==(other); end
end

# A heredoc in this case is a list of tokens that belong to the body of the
# heredoc that should be appended onto the list of tokens when the heredoc
# closes.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#251
module YARP::LexCompat::Heredoc
  class << self
    # Here we will split between the two types of heredocs and return the
    # object that will store their tokens.
    #
    # source://yarp//../../yarp/lib/yarp/lex_compat.rb#525
    def build(opening); end
  end
end

# Dash heredocs are a little more complicated. They are a list of tokens
# that need to be split on "\\\n" to mimic Ripper's behavior. We also need
# to keep track of the state that the heredoc was opened in.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#275
class YARP::LexCompat::Heredoc::DashHeredoc
  # @return [DashHeredoc] a new instance of DashHeredoc
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#278
  def initialize(split); end

  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#283
  def <<(token); end

  # Returns the value of attribute split.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#276
  def split; end

  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#287
  def to_a; end

  # Returns the value of attribute tokens.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#276
  def tokens; end
end

# Heredocs that are dedenting heredocs are a little more complicated.
# Ripper outputs on_ignored_sp tokens for the whitespace that is being
# removed from the output. YARP only modifies the node itself and keeps
# the token the same. This simplifies YARP, but makes comparing against
# Ripper much harder because there is a length mismatch.
#
# Fortunately, we already have to pull out the heredoc tokens in order to
# insert them into the stream in the correct order. As such, we can do
# some extra manipulation on the tokens to make them match Ripper's
# output by mirroring the dedent logic that Ripper uses.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#334
class YARP::LexCompat::Heredoc::DedentingHeredoc
  # @return [DedentingHeredoc] a new instance of DedentingHeredoc
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#339
  def initialize; end

  # As tokens are coming in, we track the minimum amount of common leading
  # whitespace on plain string content tokens. This allows us to later
  # remove that amount of whitespace from the beginning of each line.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#349
  def <<(token); end

  # Returns the value of attribute dedent.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#337
  def dedent; end

  # Returns the value of attribute dedent_next.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#337
  def dedent_next; end

  # Returns the value of attribute embexpr_balance.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#337
  def embexpr_balance; end

  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#381
  def to_a; end

  # Returns the value of attribute tokens.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#337
  def tokens; end
end

# source://yarp//../../yarp/lib/yarp/lex_compat.rb#335
YARP::LexCompat::Heredoc::DedentingHeredoc::TAB_WIDTH = T.let(T.unsafe(nil), Integer)

# Heredocs that are no dash or tilde heredocs are just a list of tokens.
# We need to keep them around so that we can insert them in the correct
# order back into the token stream and set the state of the last token to
# the state that the heredoc was opened in.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#256
class YARP::LexCompat::Heredoc::PlainHeredoc
  # @return [PlainHeredoc] a new instance of PlainHeredoc
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#259
  def initialize; end

  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#263
  def <<(token); end

  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#267
  def to_a; end

  # Returns the value of attribute tokens.
  #
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#257
  def tokens; end
end

# Heredoc end tokens are emitted in an odd order, so we don't compare the
# state on them.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#215
class YARP::LexCompat::HeredocEndToken < ::YARP::LexCompat::Token
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#216
  def ==(other); end
end

# Ident tokens for the most part are exactly the same, except sometimes we
# know an ident is a local when ripper doesn't (when they are introduced
# through named captures in regular expressions). In that case we don't
# compare the state.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#225
class YARP::LexCompat::IdentToken < ::YARP::LexCompat::Token
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#226
  def ==(other); end
end

# Ignored newlines can occasionally have a LABEL state attached to them, so
# we compare the state differently here.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#236
class YARP::LexCompat::IgnoredNewlineToken < ::YARP::LexCompat::Token
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#237
  def ==(other); end
end

# This is a mapping of YARP token types to Ripper token types. This is a
# many-to-one mapping because we split up our token types, whereas Ripper
# tends to group them.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#15
YARP::LexCompat::RIPPER = T.let(T.unsafe(nil), Hash)

# When we produce tokens, we produce the same arrays that Ripper does.
# However, we add a couple of convenience methods onto them to make them a
# little easier to work with. We delegate all other methods to the array.
#
# source://yarp//../../yarp/lib/yarp/lex_compat.rb#178
class YARP::LexCompat::Token < ::SimpleDelegator
  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#183
  def event; end

  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#179
  def location; end

  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#191
  def state; end

  # source://yarp//../../yarp/lib/yarp/lex_compat.rb#187
  def value; end
end

# Represents the use of the `&&=` operator for assignment to a local variable.
#
#     target &&= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3617
class YARP::LocalVariableOperatorAndWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, constant_id: Symbol, location: Location) -> void
  #
  # @return [LocalVariableOperatorAndWriteNode] a new instance of LocalVariableOperatorAndWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3631
  def initialize(name_loc, operator_loc, value, constant_id, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3640
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3645
  def child_nodes; end

  # attr_reader constant_id: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3628
  def constant_id; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3645
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3653
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3658
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3619
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3663
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3622
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3625
  def value; end
end

# Represents the use of the `||=` operator for assignment to a local variable.
#
#     target ||= value
#     ^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3672
class YARP::LocalVariableOperatorOrWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, constant_id: Symbol, location: Location) -> void
  #
  # @return [LocalVariableOperatorOrWriteNode] a new instance of LocalVariableOperatorOrWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3686
  def initialize(name_loc, operator_loc, value, constant_id, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3695
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3700
  def child_nodes; end

  # attr_reader constant_id: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3683
  def constant_id; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3700
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3708
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3713
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3674
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3718
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3677
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3680
  def value; end
end

# Represents assigning to a local variable using an operator that isn't `=`.
#
#     target += value
#     ^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3727
class YARP::LocalVariableOperatorWriteNode < ::YARP::Node
  # def initialize: (name_loc: Location, operator_loc: Location, value: Node, constant_id: Symbol, operator_id: Symbol, location: Location) -> void
  #
  # @return [LocalVariableOperatorWriteNode] a new instance of LocalVariableOperatorWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3744
  def initialize(name_loc, operator_loc, value, constant_id, operator_id, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3754
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3759
  def child_nodes; end

  # attr_reader constant_id: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3738
  def constant_id; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3759
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3767
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3772
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3729
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3777
  def operator; end

  # attr_reader operator_id: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3741
  def operator_id; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3732
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3735
  def value; end
end

# Represents reading a local variable. Note that this requires that a local
# variable of the same name has already been written to in the same scope,
# otherwise it is parsed as a method call.
#
#     foo
#     ^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3788
class YARP::LocalVariableReadNode < ::YARP::Node
  # def initialize: (constant_id: Symbol, depth: Integer, location: Location) -> void
  #
  # @return [LocalVariableReadNode] a new instance of LocalVariableReadNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3796
  def initialize(constant_id, depth, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3803
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3808
  def child_nodes; end

  # attr_reader constant_id: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3790
  def constant_id; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3808
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3816
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3793
  def depth; end
end

# Represents writing to a local variable.
#
#     foo = 1
#     ^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3825
class YARP::LocalVariableWriteNode < ::YARP::Node
  # def initialize: (constant_id: Symbol, depth: Integer, value: Node?, name_loc: Location, operator_loc: Location?, location: Location) -> void
  #
  # @return [LocalVariableWriteNode] a new instance of LocalVariableWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3842
  def initialize(constant_id, depth, value, name_loc, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3852
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3857
  def child_nodes; end

  # attr_reader constant_id: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3827
  def constant_id; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3857
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3865
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3830
  def depth; end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3870
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3836
  def name_loc; end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3875
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3839
  def operator_loc; end

  # attr_reader value: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3833
  def value; end
end

# This represents a location in the source.
#
# source://yarp//../../yarp/lib/yarp.rb#29
class YARP::Location
  # @return [Location] a new instance of Location
  #
  # source://yarp//../../yarp/lib/yarp.rb#41
  def initialize(source, start_offset, length); end

  # source://yarp//../../yarp/lib/yarp.rb#91
  def ==(other); end

  # source://yarp//../../yarp/lib/yarp.rb#83
  def deconstruct_keys(keys); end

  # The column number in bytes where this location ends from the start of the
  # line.
  #
  # source://yarp//../../yarp/lib/yarp.rb#79
  def end_column; end

  # The line number where this location ends.
  #
  # source://yarp//../../yarp/lib/yarp.rb#67
  def end_line; end

  # The byte offset from the beginning of the source where this location ends.
  #
  # source://yarp//../../yarp/lib/yarp.rb#57
  def end_offset; end

  # source://yarp//../../yarp/lib/yarp.rb#47
  def inspect; end

  # The length of this location in bytes.
  #
  # source://yarp//../../yarp/lib/yarp.rb#39
  def length; end

  # source://yarp//../../yarp/lib/yarp.rb#87
  def pretty_print(q); end

  # The source code that this location represents.
  #
  # source://yarp//../../yarp/lib/yarp.rb#52
  def slice; end

  # The column number in bytes where this location starts from the start of
  # the line.
  #
  # source://yarp//../../yarp/lib/yarp.rb#73
  def start_column; end

  # The line number where this location starts.
  #
  # source://yarp//../../yarp/lib/yarp.rb#62
  def start_line; end

  # The byte offset from the beginning of the source where this location
  # starts.
  #
  # source://yarp//../../yarp/lib/yarp.rb#36
  def start_offset; end

  private

  # Returns the value of attribute source.
  #
  # source://yarp//../../yarp/lib/yarp.rb#32
  def source; end

  class << self
    # source://yarp//../../yarp/lib/yarp.rb#95
    def null; end
  end
end

# Represents the use of the modifier `in` operator.
#
#     foo in bar
#     ^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3884
class YARP::MatchPredicateNode < ::YARP::Node
  # def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [MatchPredicateNode] a new instance of MatchPredicateNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3895
  def initialize(value, pattern, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3903
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3908
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3908
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3916
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3921
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3892
  def operator_loc; end

  # attr_reader pattern: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3889
  def pattern; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3886
  def value; end
end

# Represents the use of the `=>` operator.
#
#     foo => bar
#     ^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#3930
class YARP::MatchRequiredNode < ::YARP::Node
  # def initialize: (value: Node, pattern: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [MatchRequiredNode] a new instance of MatchRequiredNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3941
  def initialize(value, pattern, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3949
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3954
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3954
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3962
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3967
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3938
  def operator_loc; end

  # attr_reader pattern: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3935
  def pattern; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3932
  def value; end
end

# Represents a node that is missing from the source and results in a syntax
# error.
#
# source://yarp//../../yarp/lib/yarp/node.rb#3974
class YARP::MissingNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [MissingNode] a new instance of MissingNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3976
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3981
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3986
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3986
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#3994
  def deconstruct_keys(keys); end
end

# Represents a module declaration involving the `module` keyword.
#
#     module Foo end
#     ^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4003
class YARP::ModuleNode < ::YARP::Node
  # def initialize: (locals: Array[Symbol], module_keyword_loc: Location, constant_path: Node, statements: Node?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [ModuleNode] a new instance of ModuleNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4020
  def initialize(locals, module_keyword_loc, constant_path, statements, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4030
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4035
  def child_nodes; end

  # attr_reader constant_path: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4011
  def constant_path; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4035
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4043
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4053
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4017
  def end_keyword_loc; end

  # attr_reader locals: Array[Symbol]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4005
  def locals; end

  # def module_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4048
  def module_keyword; end

  # attr_reader module_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4008
  def module_keyword_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4014
  def statements; end
end

# Represents a multi-target expression.
#
#     a, b, c = 1, 2, 3
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4062
class YARP::MultiWriteNode < ::YARP::Node
  # def initialize: (targets: Array[Node], operator_loc: Location?, value: Node?, lparen_loc: Location?, rparen_loc: Location?, location: Location) -> void
  #
  # @return [MultiWriteNode] a new instance of MultiWriteNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4079
  def initialize(targets, operator_loc, value, lparen_loc, rparen_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4089
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4094
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4094
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4102
  def deconstruct_keys(keys); end

  # def lparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4112
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4073
  def lparen_loc; end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4107
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4067
  def operator_loc; end

  # def rparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4117
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4076
  def rparen_loc; end

  # attr_reader targets: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4064
  def targets; end

  # attr_reader value: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4070
  def value; end
end

# Represents the use of the `next` keyword.
#
#     next 1
#     ^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4126
class YARP::NextNode < ::YARP::Node
  # def initialize: (arguments: Node?, keyword_loc: Location, location: Location) -> void
  #
  # @return [NextNode] a new instance of NextNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4134
  def initialize(arguments, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4141
  def accept(visitor); end

  # attr_reader arguments: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4128
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4146
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4146
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4154
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4159
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4131
  def keyword_loc; end
end

# Represents the use of the `nil` keyword.
#
#     nil
#     ^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4168
class YARP::NilNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [NilNode] a new instance of NilNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4170
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4175
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4180
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4180
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4188
  def deconstruct_keys(keys); end
end

# Represents the use of `**nil` inside method arguments.
#
#     def a(**nil)
#           ^^^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#4198
class YARP::NoKeywordsParameterNode < ::YARP::Node
  # def initialize: (operator_loc: Location, keyword_loc: Location, location: Location) -> void
  #
  # @return [NoKeywordsParameterNode] a new instance of NoKeywordsParameterNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4206
  def initialize(operator_loc, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4213
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4218
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4218
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4226
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4236
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4203
  def keyword_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4231
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4200
  def operator_loc; end
end

# This represents a node in the tree.
#
# source://yarp//../../yarp/lib/yarp.rb#203
class YARP::Node
  # Returns the value of attribute location.
  #
  # source://yarp//../../yarp/lib/yarp.rb#204
  def location; end

  # source://yarp//../../yarp/lib/yarp.rb#206
  def pretty_print(q); end
end

# Represents reading a numbered reference to a capture in the previous match.
#
#     $1
#     ^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4245
class YARP::NumberedReferenceReadNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [NumberedReferenceReadNode] a new instance of NumberedReferenceReadNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4247
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4252
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4257
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4257
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4265
  def deconstruct_keys(keys); end
end

# Represents an optional parameter to a method, block, or lambda definition.
#
#     def a(b = 1)
#           ^^^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#4275
class YARP::OptionalParameterNode < ::YARP::Node
  # def initialize: (constant_id: Symbol, name_loc: Location, operator_loc: Location, value: Node, location: Location) -> void
  #
  # @return [OptionalParameterNode] a new instance of OptionalParameterNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4289
  def initialize(constant_id, name_loc, operator_loc, value, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4298
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4303
  def child_nodes; end

  # attr_reader constant_id: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4277
  def constant_id; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4303
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4311
  def deconstruct_keys(keys); end

  # def name: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4316
  def name; end

  # attr_reader name_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4280
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4321
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4283
  def operator_loc; end

  # attr_reader value: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4286
  def value; end
end

# Represents the use of the `||` operator or the `or` keyword.
#
#     left or right
#     ^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4330
class YARP::OrNode < ::YARP::Node
  # def initialize: (left: Node, right: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [OrNode] a new instance of OrNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4341
  def initialize(left, right, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4349
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4354
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4354
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4362
  def deconstruct_keys(keys); end

  # attr_reader left: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4332
  def left; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4367
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4338
  def operator_loc; end

  # attr_reader right: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4335
  def right; end
end

# source://yarp//../../yarp/lib/yarp/pack.rb#4
module YARP::Pack
  class << self
    def parse(_arg0, _arg1, _arg2); end
  end
end

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::AGNOSTIC_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::BACK = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::BER = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::BIG_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::COMMENT = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#57
class YARP::Pack::Directive
  # @return [Directive] a new instance of Directive
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#60
  def initialize(version, variant, source, type, signed, endian, size, length_type, length); end

  # source://yarp//../../yarp/lib/yarp/pack.rb#98
  def describe; end

  # Returns the value of attribute endian.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#58
  def endian; end

  # Returns the value of attribute length.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#58
  def length; end

  # Returns the value of attribute length_type.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#58
  def length_type; end

  # Returns the value of attribute signed.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#58
  def signed; end

  # Returns the value of attribute size.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#58
  def size; end

  # Returns the value of attribute source.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#58
  def source; end

  # Returns the value of attribute type.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#58
  def type; end

  # Returns the value of attribute variant.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#58
  def variant; end

  # Returns the value of attribute version.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#58
  def version; end
end

# source://yarp//../../yarp/lib/yarp/pack.rb#72
YARP::Pack::Directive::ENDIAN_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# source://yarp//../../yarp/lib/yarp/pack.rb#80
YARP::Pack::Directive::SIGNED_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# source://yarp//../../yarp/lib/yarp/pack.rb#86
YARP::Pack::Directive::SIZE_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::ENDIAN_NA = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::FLOAT = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#162
class YARP::Pack::Format
  # @return [Format] a new instance of Format
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#165
  def initialize(directives, encoding); end

  # source://yarp//../../yarp/lib/yarp/pack.rb#170
  def describe; end

  # Returns the value of attribute directives.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#163
  def directives; end

  # Returns the value of attribute encoding.
  #
  # source://yarp//../../yarp/lib/yarp/pack.rb#163
  def encoding; end
end

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::INTEGER = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::LENGTH_FIXED = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::LENGTH_MAX = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::LENGTH_NA = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::LENGTH_RELATIVE = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::LITTLE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::MOVE = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::NATIVE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::NULL = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIGNED = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIGNED_NA = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_16 = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_32 = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_64 = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_8 = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_INT = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_LONG = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_LONG_LONG = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_NA = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_P = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SIZE_SHORT = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::SPACE = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_BASE64 = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_FIXED = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_HEX_HIGH = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_HEX_LOW = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_LSB = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_MIME = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_MSB = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_NULL_PADDED = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_NULL_TERMINATED = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_POINTER = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_SPACE_PADDED = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::STRING_UU = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::UNSIGNED = T.let(T.unsafe(nil), Symbol)

# source://yarp//../../yarp/lib/yarp/pack.rb#54
YARP::Pack::UTF8 = T.let(T.unsafe(nil), Symbol)

# Represents the list of parameters on a method, block, or lambda definition.
#
#     def a(b, c, d)
#           ^^^^^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#4377
class YARP::ParametersNode < ::YARP::Node
  # def initialize: (requireds: Array[Node], optionals: Array[Node], posts: Array[Node], rest: Node?, keywords: Array[Node], keyword_rest: Node?, block: Node?, location: Location) -> void
  #
  # @return [ParametersNode] a new instance of ParametersNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4400
  def initialize(requireds, optionals, posts, rest, keywords, keyword_rest, block, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4412
  def accept(visitor); end

  # attr_reader block: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4397
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4417
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4417
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4425
  def deconstruct_keys(keys); end

  # attr_reader keyword_rest: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4394
  def keyword_rest; end

  # attr_reader keywords: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4391
  def keywords; end

  # attr_reader optionals: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4382
  def optionals; end

  # attr_reader posts: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4385
  def posts; end

  # attr_reader requireds: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4379
  def requireds; end

  # attr_reader rest: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4388
  def rest; end
end

# Represents a parenthesized expression
#
#     (10 + 34)
#     ^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4434
class YARP::ParenthesesNode < ::YARP::Node
  # def initialize: (statements: Node?, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [ParenthesesNode] a new instance of ParenthesesNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4445
  def initialize(statements, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4453
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4458
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4476
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4442
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4458
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4466
  def deconstruct_keys(keys); end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4471
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4439
  def opening_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4436
  def statements; end
end

# This represents an error that was encountered during parsing.
#
# source://yarp//../../yarp/lib/yarp.rb#115
class YARP::ParseError
  # @return [ParseError] a new instance of ParseError
  #
  # source://yarp//../../yarp/lib/yarp.rb#118
  def initialize(message, location); end

  # source://yarp//../../yarp/lib/yarp.rb#123
  def deconstruct_keys(keys); end

  # Returns the value of attribute location.
  #
  # source://yarp//../../yarp/lib/yarp.rb#116
  def location; end

  # Returns the value of attribute message.
  #
  # source://yarp//../../yarp/lib/yarp.rb#116
  def message; end
end

# This represents the result of a call to ::parse or ::parse_file. It contains
# the AST, any comments that were encounters, and any errors that were
# encountered.
#
# source://yarp//../../yarp/lib/yarp.rb#145
class YARP::ParseResult
  # @return [ParseResult] a new instance of ParseResult
  #
  # source://yarp//../../yarp/lib/yarp.rb#148
  def initialize(value, comments, errors, warnings, source); end

  # Returns the value of attribute comments.
  #
  # source://yarp//../../yarp/lib/yarp.rb#146
  def comments; end

  # source://yarp//../../yarp/lib/yarp.rb#156
  def deconstruct_keys(keys); end

  # Returns the value of attribute errors.
  #
  # source://yarp//../../yarp/lib/yarp.rb#146
  def errors; end

  # @return [Boolean]
  #
  # source://yarp//../../yarp/lib/yarp.rb#164
  def failure?; end

  # Returns the value of attribute source.
  #
  # source://yarp//../../yarp/lib/yarp.rb#146
  def source; end

  # @return [Boolean]
  #
  # source://yarp//../../yarp/lib/yarp.rb#160
  def success?; end

  # Returns the value of attribute value.
  #
  # source://yarp//../../yarp/lib/yarp.rb#146
  def value; end

  # Returns the value of attribute warnings.
  #
  # source://yarp//../../yarp/lib/yarp.rb#146
  def warnings; end
end

# This represents a warning that was encountered during parsing.
#
# source://yarp//../../yarp/lib/yarp.rb#129
class YARP::ParseWarning
  # @return [ParseWarning] a new instance of ParseWarning
  #
  # source://yarp//../../yarp/lib/yarp.rb#132
  def initialize(message, location); end

  # source://yarp//../../yarp/lib/yarp.rb#137
  def deconstruct_keys(keys); end

  # Returns the value of attribute location.
  #
  # source://yarp//../../yarp/lib/yarp.rb#130
  def location; end

  # Returns the value of attribute message.
  #
  # source://yarp//../../yarp/lib/yarp.rb#130
  def message; end
end

# Represents the use of the `^` operator for pinning an expression in a
# pattern matching expression.
#
#     foo in ^(bar)
#            ^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4486
class YARP::PinnedExpressionNode < ::YARP::Node
  # def initialize: (expression: Node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location, location: Location) -> void
  #
  # @return [PinnedExpressionNode] a new instance of PinnedExpressionNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4500
  def initialize(expression, operator_loc, lparen_loc, rparen_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4509
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4514
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4514
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4522
  def deconstruct_keys(keys); end

  # attr_reader expression: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4488
  def expression; end

  # def lparen: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4532
  def lparen; end

  # attr_reader lparen_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4494
  def lparen_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4527
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4491
  def operator_loc; end

  # def rparen: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4537
  def rparen; end

  # attr_reader rparen_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4497
  def rparen_loc; end
end

# Represents the use of the `^` operator for pinning a variable in a pattern
# matching expression.
#
#     foo in ^bar
#            ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4547
class YARP::PinnedVariableNode < ::YARP::Node
  # def initialize: (variable: Node, operator_loc: Location, location: Location) -> void
  #
  # @return [PinnedVariableNode] a new instance of PinnedVariableNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4555
  def initialize(variable, operator_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4562
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4567
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4567
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4575
  def deconstruct_keys(keys); end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4580
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4552
  def operator_loc; end

  # attr_reader variable: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4549
  def variable; end
end

# Represents the use of the `END` keyword.
#
#     END { foo }
#     ^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4589
class YARP::PostExecutionNode < ::YARP::Node
  # def initialize: (statements: Node?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [PostExecutionNode] a new instance of PostExecutionNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4603
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4612
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4617
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4640
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4600
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4617
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4625
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4630
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4594
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4635
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4597
  def opening_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4591
  def statements; end
end

# Represents the use of the `BEGIN` keyword.
#
#     BEGIN { foo }
#     ^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4649
class YARP::PreExecutionNode < ::YARP::Node
  # def initialize: (statements: Node?, keyword_loc: Location, opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [PreExecutionNode] a new instance of PreExecutionNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4663
  def initialize(statements, keyword_loc, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4672
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4677
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4700
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4660
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4677
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4685
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4690
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4654
  def keyword_loc; end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4695
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4657
  def opening_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4651
  def statements; end
end

# The top level node of any parse tree.
#
# source://yarp//../../yarp/lib/yarp/node.rb#4706
class YARP::ProgramNode < ::YARP::Node
  # def initialize: (locals: Array[Symbol], statements: Node, location: Location) -> void
  #
  # @return [ProgramNode] a new instance of ProgramNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4714
  def initialize(locals, statements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4721
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4726
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4726
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4734
  def deconstruct_keys(keys); end

  # attr_reader locals: Array[Symbol]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4708
  def locals; end

  # attr_reader statements: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4711
  def statements; end
end

# Represents the use of the `..` or `...` operators.
#
#     1..2
#     ^^^^
#
#     c if a =~ /left/ ... b =~ /right/
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4746
class YARP::RangeNode < ::YARP::Node
  # def initialize: (left: Node?, right: Node?, operator_loc: Location, flags: Integer, location: Location) -> void
  #
  # @return [RangeNode] a new instance of RangeNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4760
  def initialize(left, right, operator_loc, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4769
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4774
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4774
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4782
  def deconstruct_keys(keys); end

  # attr_reader flags: Integer
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4757
  def flags; end

  # attr_reader left: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4748
  def left; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4787
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4754
  def operator_loc; end

  # attr_reader right: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4751
  def right; end
end

# source://yarp//../../yarp/lib/yarp/node.rb#6134
module YARP::RangeNodeFlags; end

# ... operator
#
# source://yarp//../../yarp/lib/yarp/node.rb#6136
YARP::RangeNodeFlags::EXCLUDE_END = T.let(T.unsafe(nil), Integer)

# Represents a rational number literal.
#
#     1.0r
#     ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4796
class YARP::RationalNode < ::YARP::Node
  # def initialize: (numeric: Node, location: Location) -> void
  #
  # @return [RationalNode] a new instance of RationalNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4801
  def initialize(numeric, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4807
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4812
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4812
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4820
  def deconstruct_keys(keys); end

  # attr_reader numeric: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4798
  def numeric; end
end

# Represents the use of the `redo` keyword.
#
#     redo
#     ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4829
class YARP::RedoNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [RedoNode] a new instance of RedoNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4831
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4836
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4841
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4841
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4849
  def deconstruct_keys(keys); end
end

# source://yarp//../../yarp/lib/yarp/node.rb#6139
module YARP::RegularExpressionFlags; end

# n - forces the ASCII-8BIT encoding
#
# source://yarp//../../yarp/lib/yarp/node.rb#6153
YARP::RegularExpressionFlags::ASCII_8BIT = T.let(T.unsafe(nil), Integer)

# e - forces the EUC-JP encoding
#
# source://yarp//../../yarp/lib/yarp/node.rb#6150
YARP::RegularExpressionFlags::EUC_JP = T.let(T.unsafe(nil), Integer)

# x - ignores whitespace and allows comments in regular expressions
#
# source://yarp//../../yarp/lib/yarp/node.rb#6147
YARP::RegularExpressionFlags::EXTENDED = T.let(T.unsafe(nil), Integer)

# i - ignores the case of characters when matching
#
# source://yarp//../../yarp/lib/yarp/node.rb#6141
YARP::RegularExpressionFlags::IGNORE_CASE = T.let(T.unsafe(nil), Integer)

# m - allows $ to match the end of lines within strings
#
# source://yarp//../../yarp/lib/yarp/node.rb#6144
YARP::RegularExpressionFlags::MULTI_LINE = T.let(T.unsafe(nil), Integer)

# o - only interpolates values into the regular expression once
#
# source://yarp//../../yarp/lib/yarp/node.rb#6162
YARP::RegularExpressionFlags::ONCE = T.let(T.unsafe(nil), Integer)

# u - forces the UTF-8 encoding
#
# source://yarp//../../yarp/lib/yarp/node.rb#6159
YARP::RegularExpressionFlags::UTF_8 = T.let(T.unsafe(nil), Integer)

# s - forces the Windows-31J encoding
#
# source://yarp//../../yarp/lib/yarp/node.rb#6156
YARP::RegularExpressionFlags::WINDOWS_31J = T.let(T.unsafe(nil), Integer)

# Represents a regular expression literal with no interpolation.
#
#     /foo/i
#     ^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#4858
class YARP::RegularExpressionNode < ::YARP::Node
  # def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, flags: Integer, location: Location) -> void
  #
  # @return [RegularExpressionNode] a new instance of RegularExpressionNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4875
  def initialize(opening_loc, content_loc, closing_loc, unescaped, flags, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4885
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4890
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4913
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4866
  def closing_loc; end

  # def content: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4908
  def content; end

  # attr_reader content_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4863
  def content_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4890
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4898
  def deconstruct_keys(keys); end

  # attr_reader flags: Integer
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4872
  def flags; end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4903
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4860
  def opening_loc; end

  # attr_reader unescaped: String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4869
  def unescaped; end
end

# Represents a destructured required parameter node.
#
#     def foo((bar, baz))
#             ^^^^^^^^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#4923
class YARP::RequiredDestructuredParameterNode < ::YARP::Node
  # def initialize: (parameters: Array[Node], opening_loc: Location, closing_loc: Location, location: Location) -> void
  #
  # @return [RequiredDestructuredParameterNode] a new instance of RequiredDestructuredParameterNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4934
  def initialize(parameters, opening_loc, closing_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4942
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4947
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4965
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4931
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4947
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4955
  def deconstruct_keys(keys); end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4960
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4928
  def opening_loc; end

  # attr_reader parameters: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4925
  def parameters; end
end

# Represents a required parameter to a method, block, or lambda definition.
#
#     def a(b)
#           ^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#4975
class YARP::RequiredParameterNode < ::YARP::Node
  # def initialize: (constant_id: Symbol, location: Location) -> void
  #
  # @return [RequiredParameterNode] a new instance of RequiredParameterNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4980
  def initialize(constant_id, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4986
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4991
  def child_nodes; end

  # attr_reader constant_id: Symbol
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4977
  def constant_id; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4991
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#4999
  def deconstruct_keys(keys); end
end

# Represents an expression modified with a rescue.
#
#   foo rescue nil
#   ^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5008
class YARP::RescueModifierNode < ::YARP::Node
  # def initialize: (expression: Node, keyword_loc: Location, rescue_expression: Node, location: Location) -> void
  #
  # @return [RescueModifierNode] a new instance of RescueModifierNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5019
  def initialize(expression, keyword_loc, rescue_expression, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5027
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5032
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5032
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5040
  def deconstruct_keys(keys); end

  # attr_reader expression: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5010
  def expression; end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5045
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5013
  def keyword_loc; end

  # attr_reader rescue_expression: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5016
  def rescue_expression; end
end

# Represents a rescue statement.
#
#     begin
#     rescue
#       foo
#     ^^^^^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#5057
class YARP::RescueNode < ::YARP::Node
  # def initialize: (keyword_loc: Location, exceptions: Array[Node], operator_loc: Location?, exception: Node?, statements: Node?, consequent: Node?, location: Location) -> void
  #
  # @return [RescueNode] a new instance of RescueNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5077
  def initialize(keyword_loc, exceptions, operator_loc, exception, statements, consequent, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5088
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5093
  def child_nodes; end

  # attr_reader consequent: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5074
  def consequent; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5093
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5101
  def deconstruct_keys(keys); end

  # attr_reader exception: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5068
  def exception; end

  # attr_reader exceptions: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5062
  def exceptions; end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5106
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5059
  def keyword_loc; end

  # def operator: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5111
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5065
  def operator_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5071
  def statements; end
end

# Represents a rest parameter to a method, block, or lambda definition.
#
#     def a(*b)
#           ^^
#     end
#
# source://yarp//../../yarp/lib/yarp/node.rb#5121
class YARP::RestParameterNode < ::YARP::Node
  # def initialize: (operator_loc: Location, name_loc: Location?, location: Location) -> void
  #
  # @return [RestParameterNode] a new instance of RestParameterNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5129
  def initialize(operator_loc, name_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5136
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5141
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5141
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5149
  def deconstruct_keys(keys); end

  # def name: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5159
  def name; end

  # attr_reader name_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5126
  def name_loc; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5154
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5123
  def operator_loc; end
end

# Represents the use of the `retry` keyword.
#
#     retry
#     ^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5168
class YARP::RetryNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [RetryNode] a new instance of RetryNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5170
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5175
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5180
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5180
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5188
  def deconstruct_keys(keys); end
end

# Represents the use of the `return` keyword.
#
#     return 1
#     ^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5197
class YARP::ReturnNode < ::YARP::Node
  # def initialize: (keyword_loc: Location, arguments: Node?, location: Location) -> void
  #
  # @return [ReturnNode] a new instance of ReturnNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5205
  def initialize(keyword_loc, arguments, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5212
  def accept(visitor); end

  # attr_reader arguments: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5202
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5217
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5217
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5225
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5230
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5199
  def keyword_loc; end
end

# This class is meant to provide a compatibility layer between YARP and
# Ripper. It functions by parsing the entire tree first and then walking it
# and executing each of the Ripper callbacks as it goes.
#
# This class is going to necessarily be slower than the native Ripper API. It
# is meant as a stopgap until developers migrate to using YARP. It is also
# meant as a test harness for the YARP parser.
#
# source://yarp//../../yarp/lib/yarp/ripper_compat.rb#13
class YARP::RipperCompat
  # @return [RipperCompat] a new instance of RipperCompat
  #
  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#59
  def initialize(source); end

  # Returns the value of attribute column.
  #
  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#57
  def column; end

  # Public interface
  #
  # @return [Boolean]
  #
  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#70
  def error?; end

  # Returns the value of attribute lineno.
  #
  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#57
  def lineno; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#74
  def parse; end

  # Returns the value of attribute source.
  #
  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#57
  def source; end

  # Visitor methods
  #
  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#82
  def visit(node); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#86
  def visit_call_node(node); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#100
  def visit_integer_node(node); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#125
  def visit_program_node(node); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#105
  def visit_statements_node(node); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#112
  def visit_token(node); end

  private

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def _dispatch0; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def _dispatch1(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def _dispatch2(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def _dispatch3(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#166
  def _dispatch4(_, _, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#167
  def _dispatch5(_, _, _, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#168
  def _dispatch7(_, _, _, _, _, _, _); end

  # This method is responsible for updating lineno and column information
  # to reflect the current node.
  #
  # This method could be drastically improved with some caching on the start
  # of every line, but for now it's good enough.
  #
  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#151
  def bounds(location); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_BEGIN(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_CHAR(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_END(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on___end__(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_alias(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_alias_error(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_aref(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_aref_field(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_arg_ambiguous(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_arg_paren(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_args_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_args_add_block(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_args_add_star(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_args_forward; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_args_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_array(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#166
  def on_aryptn(_, _, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_assign(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_assign_error(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_assoc_new(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_assoc_splat(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_assoclist_from_args(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_backref(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_backtick(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_bare_assoc_hash(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_begin(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_binary(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_block_var(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_blockarg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#166
  def on_bodystmt(_, _, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_brace_block(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_break(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_call(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_case(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_class(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_class_name_error(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_comma(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_command(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#166
  def on_command_call(_, _, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_comment(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_const(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_const_path_field(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_const_path_ref(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_const_ref(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_cvar(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_def(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_defined(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#167
  def on_defs(_, _, _, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_do_block(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_dot2(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_dot3(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_dyna_symbol(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_else(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_elsif(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_embdoc(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_embdoc_beg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_embdoc_end(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_embexpr_beg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_embexpr_end(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_embvar(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_ensure(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_excessed_comma; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_fcall(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_field(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_float(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#166
  def on_fndptn(_, _, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_for(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_gvar(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_hash(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_heredoc_beg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_heredoc_dedent(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_heredoc_end(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_hshptn(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_ident(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_if(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_if_mod(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_ifop(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_ignored_nl(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_ignored_sp(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_imaginary(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_in(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_int(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_ivar(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_kw(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_kwrest_param(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_label(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_label_end(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_lambda(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_lbrace(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_lbracket(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_lparen(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_magic_comment(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_massign(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_method_add_arg(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_method_add_block(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_mlhs_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_mlhs_add_post(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_mlhs_add_star(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_mlhs_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_mlhs_paren(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_module(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_mrhs_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_mrhs_add_star(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_mrhs_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_mrhs_new_from_args(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_next(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_nl(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_nokw_param(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_op(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_opassign(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_operator_ambiguous(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_param_error(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#168
  def on_params(_, _, _, _, _, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_paren(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_parse_error(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_period(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_program(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_qsymbols_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_qsymbols_beg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_qsymbols_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_qwords_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_qwords_beg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_qwords_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_rational(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_rbrace(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_rbracket(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_redo; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_regexp_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_regexp_beg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_regexp_end(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_regexp_literal(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_regexp_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#166
  def on_rescue(_, _, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_rescue_mod(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_rest_param(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_retry; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_return(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_return0; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_rparen(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_sclass(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_semicolon(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_sp(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_stmts_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_stmts_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_string_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_string_concat(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_string_content; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_string_dvar(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_string_embexpr(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_string_literal(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_super(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_symbeg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_symbol(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_symbol_literal(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_symbols_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_symbols_beg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_symbols_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_tlambda(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_tlambeg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_top_const_field(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_top_const_ref(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_tstring_beg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_tstring_content(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_tstring_end(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_unary(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_undef(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_unless(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_unless_mod(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_until(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_until_mod(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_var_alias(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_var_field(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_var_ref(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_vcall(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_void_stmt; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#165
  def on_when(_, _, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_while(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_while_mod(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_word_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_word_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_words_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_words_beg(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_words_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_words_sep(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#164
  def on_xstring_add(_, _); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_xstring_literal(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_xstring_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#163
  def on_yield(_); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_yield0; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#162
  def on_zsuper; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#158
  def result; end

  class << self
    # This is a convenience method that runs the SexpBuilderPP subclass parser.
    #
    # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#140
    def sexp(source); end

    # This is a convenience method that runs the SexpBuilder subclass parser.
    #
    # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#135
    def sexp_raw(source); end
  end
end

# This class mirrors the ::Ripper::SexpBuilder subclass of ::Ripper that
# returns the arrays of [type, *children].
#
# source://yarp//../../yarp/lib/yarp/ripper_compat.rb#16
class YARP::RipperCompat::SexpBuilder < ::YARP::RipperCompat
  private

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_BEGIN(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_CHAR(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_END(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on___end__(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_alias(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_alias_error(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_aref(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_aref_field(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_arg_ambiguous(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_arg_paren(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_args_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_args_add_block(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_args_add_star(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_args_forward(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_args_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_array(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_aryptn(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_assign(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_assign_error(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_assoc_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_assoc_splat(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_assoclist_from_args(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_backref(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_backtick(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_bare_assoc_hash(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_begin(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_binary(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_block_var(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_blockarg(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_bodystmt(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_brace_block(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_break(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_call(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_case(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_class(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_class_name_error(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_comma(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_command(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_command_call(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_comment(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_const(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_const_path_field(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_const_path_ref(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_const_ref(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_cvar(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_def(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_defined(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_defs(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_do_block(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_dot2(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_dot3(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_dyna_symbol(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_else(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_elsif(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_embdoc(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_embdoc_beg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_embdoc_end(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_embexpr_beg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_embexpr_end(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_embvar(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_ensure(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_excessed_comma(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_fcall(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_field(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_float(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_fndptn(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_for(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_gvar(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_hash(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_heredoc_beg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_heredoc_dedent(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_heredoc_end(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_hshptn(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_ident(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_if(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_if_mod(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_ifop(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_ignored_nl(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_ignored_sp(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_imaginary(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_in(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_int(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_ivar(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_kw(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_kwrest_param(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_label(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_label_end(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_lambda(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_lbrace(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_lbracket(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_lparen(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_magic_comment(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_massign(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_method_add_arg(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_method_add_block(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_mlhs_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_mlhs_add_post(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_mlhs_add_star(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_mlhs_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_mlhs_paren(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_module(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_mrhs_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_mrhs_add_star(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_mrhs_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_mrhs_new_from_args(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_next(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_nl(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_nokw_param(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_op(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_opassign(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_operator_ambiguous(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_param_error(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_params(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_paren(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_parse_error(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_period(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_program(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_qsymbols_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_qsymbols_beg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_qsymbols_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_qwords_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_qwords_beg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_qwords_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_rational(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_rbrace(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_rbracket(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_redo(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_regexp_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_regexp_beg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_regexp_end(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_regexp_literal(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_regexp_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_rescue(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_rescue_mod(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_rest_param(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_retry(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_return(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_return0(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_rparen(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_sclass(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_semicolon(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_sp(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_stmts_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_stmts_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_string_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_string_concat(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_string_content(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_string_dvar(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_string_embexpr(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_string_literal(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_super(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_symbeg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_symbol(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_symbol_literal(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_symbols_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_symbols_beg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_symbols_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_tlambda(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_tlambeg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_top_const_field(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_top_const_ref(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_tstring_beg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_tstring_content(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_tstring_end(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_unary(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_undef(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_unless(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_unless_mod(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_until(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_until_mod(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_var_alias(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_var_field(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_var_ref(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_vcall(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_void_stmt(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_when(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_while(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_while_mod(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_word_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_word_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_words_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_words_beg(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_words_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#26
  def on_words_sep(value); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_xstring_add(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_xstring_literal(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_xstring_new(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_yield(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_yield0(*args); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#20
  def on_zsuper(*args); end
end

# This class mirrors the ::Ripper::SexpBuilderPP subclass of ::Ripper that
# returns the same values as ::Ripper::SexpBuilder except with a couple of
# niceties that flatten linked lists into arrays.
#
# source://yarp//../../yarp/lib/yarp/ripper_compat.rb#35
class YARP::RipperCompat::SexpBuilderPP < ::YARP::RipperCompat::SexpBuilder
  private

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def _dispatch_event_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def _dispatch_event_push(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_args_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_args_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_mlhs_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_mlhs_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_mrhs_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_mrhs_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_qsymbols_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_qsymbols_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_qwords_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_qwords_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_regexp_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_regexp_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_stmts_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_stmts_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_string_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_symbols_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_symbols_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_word_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_word_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_words_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_words_new; end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#42
  def on_xstring_add(list, item); end

  # source://yarp//../../yarp/lib/yarp/ripper_compat.rb#38
  def on_xstring_new; end
end

# Represents the `self` keyword.
#
#     self
#     ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5239
class YARP::SelfNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [SelfNode] a new instance of SelfNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5241
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5246
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5251
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5251
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5259
  def deconstruct_keys(keys); end
end

# source://yarp//../../yarp/lib/yarp/serialize.rb#11
module YARP::Serialize
  class << self
    # source://yarp//../../yarp/lib/yarp/serialize.rb#12
    def load(input, serialized); end
  end
end

# source://yarp//../../yarp/lib/yarp/serialize.rb#19
class YARP::Serialize::Loader
  # @return [Loader] a new instance of Loader
  #
  # source://yarp//../../yarp/lib/yarp/serialize.rb#23
  def initialize(input, serialized, io); end

  # Returns the value of attribute constant_pool.
  #
  # source://yarp//../../yarp/lib/yarp/serialize.rb#21
  def constant_pool; end

  # Returns the value of attribute constant_pool_offset.
  #
  # source://yarp//../../yarp/lib/yarp/serialize.rb#21
  def constant_pool_offset; end

  # Returns the value of attribute encoding.
  #
  # source://yarp//../../yarp/lib/yarp/serialize.rb#20
  def encoding; end

  # Returns the value of attribute input.
  #
  # source://yarp//../../yarp/lib/yarp/serialize.rb#20
  def input; end

  # Returns the value of attribute io.
  #
  # source://yarp//../../yarp/lib/yarp/serialize.rb#20
  def io; end

  # source://yarp//../../yarp/lib/yarp/serialize.rb#38
  def load; end

  # Returns the value of attribute serialized.
  #
  # source://yarp//../../yarp/lib/yarp/serialize.rb#20
  def serialized; end

  # Returns the value of attribute source.
  #
  # source://yarp//../../yarp/lib/yarp/serialize.rb#21
  def source; end

  private

  # source://yarp//../../yarp/lib/yarp/serialize.rb#92
  def load_constant; end

  # source://yarp//../../yarp/lib/yarp/serialize.rb#84
  def load_location; end

  # source://yarp//../../yarp/lib/yarp/serialize.rb#109
  def load_node; end

  # source://yarp//../../yarp/lib/yarp/serialize.rb#88
  def load_optional_location; end

  # source://yarp//../../yarp/lib/yarp/serialize.rb#73
  def load_optional_node; end

  # source://yarp//../../yarp/lib/yarp/serialize.rb#69
  def load_serialized_length; end

  # source://yarp//../../yarp/lib/yarp/serialize.rb#80
  def load_string; end

  # variable-length integer using https://en.wikipedia.org/wiki/LEB128
  # This is also what protobuf uses: https://protobuf.dev/programming-guides/encoding/#varints
  #
  # source://yarp//../../yarp/lib/yarp/serialize.rb#55
  def load_varint; end
end

# Represents a singleton class declaration involving the `class` keyword.
#
#     class << self end
#     ^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5268
class YARP::SingletonClassNode < ::YARP::Node
  # def initialize: (locals: Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Node, statements: Node?, end_keyword_loc: Location, location: Location) -> void
  #
  # @return [SingletonClassNode] a new instance of SingletonClassNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5288
  def initialize(locals, class_keyword_loc, operator_loc, expression, statements, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5299
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5304
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5317
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5273
  def class_keyword_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5304
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5312
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5327
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5285
  def end_keyword_loc; end

  # attr_reader expression: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5279
  def expression; end

  # attr_reader locals: Array[Symbol]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5270
  def locals; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5322
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5276
  def operator_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5282
  def statements; end
end

# This represents a source of Ruby code that has been parsed. It is used in
# conjunction with locations to allow them to resolve line numbers and source
# ranges.
#
# source://yarp//../../yarp/lib/yarp.rb#7
class YARP::Source
  # @return [Source] a new instance of Source
  #
  # source://yarp//../../yarp/lib/yarp.rb#10
  def initialize(source, offsets); end

  # source://yarp//../../yarp/lib/yarp.rb#23
  def column(value); end

  # source://yarp//../../yarp/lib/yarp.rb#19
  def line(value); end

  # Returns the value of attribute offsets.
  #
  # source://yarp//../../yarp/lib/yarp.rb#8
  def offsets; end

  # source://yarp//../../yarp/lib/yarp.rb#15
  def slice(offset, length); end

  # Returns the value of attribute source.
  #
  # source://yarp//../../yarp/lib/yarp.rb#8
  def source; end
end

# Represents the use of the `__ENCODING__` keyword.
#
#     __ENCODING__
#     ^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5336
class YARP::SourceEncodingNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [SourceEncodingNode] a new instance of SourceEncodingNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5338
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5343
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5348
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5348
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5356
  def deconstruct_keys(keys); end
end

# Represents the use of the `__FILE__` keyword.
#
#     __FILE__
#     ^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5365
class YARP::SourceFileNode < ::YARP::Node
  # def initialize: (filepath: String, location: Location) -> void
  #
  # @return [SourceFileNode] a new instance of SourceFileNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5370
  def initialize(filepath, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5376
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5381
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5381
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5389
  def deconstruct_keys(keys); end

  # attr_reader filepath: String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5367
  def filepath; end
end

# Represents the use of the `__LINE__` keyword.
#
#     __LINE__
#     ^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5398
class YARP::SourceLineNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [SourceLineNode] a new instance of SourceLineNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5400
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5405
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5410
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5410
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5418
  def deconstruct_keys(keys); end
end

# Represents the use of the splat operator.
#
#     [*a]
#      ^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5427
class YARP::SplatNode < ::YARP::Node
  # def initialize: (operator_loc: Location, expression: Node?, location: Location) -> void
  #
  # @return [SplatNode] a new instance of SplatNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5435
  def initialize(operator_loc, expression, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5442
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5447
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5447
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5455
  def deconstruct_keys(keys); end

  # attr_reader expression: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5432
  def expression; end

  # def operator: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5460
  def operator; end

  # attr_reader operator_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5429
  def operator_loc; end
end

# Represents a set of statements contained within some scope.
#
#     foo; bar; baz
#     ^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5469
class YARP::StatementsNode < ::YARP::Node
  # def initialize: (body: Array[Node], location: Location) -> void
  #
  # @return [StatementsNode] a new instance of StatementsNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5474
  def initialize(body, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5480
  def accept(visitor); end

  # attr_reader body: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5471
  def body; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5485
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5485
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5493
  def deconstruct_keys(keys); end
end

# Represents the use of compile-time string concatenation.
#
#     "foo" "bar"
#     ^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5502
class YARP::StringConcatNode < ::YARP::Node
  # def initialize: (left: Node, right: Node, location: Location) -> void
  #
  # @return [StringConcatNode] a new instance of StringConcatNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5510
  def initialize(left, right, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5517
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5522
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5522
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5530
  def deconstruct_keys(keys); end

  # attr_reader left: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5504
  def left; end

  # attr_reader right: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5507
  def right; end
end

# Represents a string literal, a string contained within a `%w` list, or
# plain string content within an interpolated string.
#
#     "foo"
#     ^^^^^
#
#     %w[foo]
#        ^^^
#
#     "foo #{bar} baz"
#      ^^^^      ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5546
class YARP::StringNode < ::YARP::Node
  # def initialize: (opening_loc: Location?, content_loc: Location, closing_loc: Location?, unescaped: String, location: Location) -> void
  #
  # @return [StringNode] a new instance of StringNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5560
  def initialize(opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5569
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5574
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5597
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5554
  def closing_loc; end

  # def content: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5592
  def content; end

  # attr_reader content_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5551
  def content_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5574
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5582
  def deconstruct_keys(keys); end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5587
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5548
  def opening_loc; end

  # attr_reader unescaped: String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5557
  def unescaped; end
end

# Represents the use of the `super` keyword with parentheses or arguments.
#
#     super()
#     ^^^^^^^
#
#     super foo, bar
#     ^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5609
class YARP::SuperNode < ::YARP::Node
  # def initialize: (keyword_loc: Location, lparen_loc: Location?, arguments: Node?, rparen_loc: Location?, block: Node?, location: Location) -> void
  #
  # @return [SuperNode] a new instance of SuperNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5626
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, block, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5636
  def accept(visitor); end

  # attr_reader arguments: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5617
  def arguments; end

  # attr_reader block: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5623
  def block; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5641
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5641
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5649
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5654
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5611
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5659
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5614
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5664
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5620
  def rparen_loc; end
end

# Represents a symbol literal or a symbol contained within a `%i` list.
#
#     :foo
#     ^^^^
#
#     %i[foo]
#        ^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5676
class YARP::SymbolNode < ::YARP::Node
  # def initialize: (opening_loc: Location?, value_loc: Location, closing_loc: Location?, unescaped: String, location: Location) -> void
  #
  # @return [SymbolNode] a new instance of SymbolNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5690
  def initialize(opening_loc, value_loc, closing_loc, unescaped, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5699
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5704
  def child_nodes; end

  # def closing: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5727
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5684
  def closing_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5704
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5712
  def deconstruct_keys(keys); end

  # def opening: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5717
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5678
  def opening_loc; end

  # attr_reader unescaped: String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5687
  def unescaped; end

  # def value: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5722
  def value; end

  # attr_reader value_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5681
  def value_loc; end
end

# This represents a token from the Ruby source.
#
# source://yarp//../../yarp/lib/yarp.rb#170
class YARP::Token
  # @return [Token] a new instance of Token
  #
  # source://yarp//../../yarp/lib/yarp.rb#173
  def initialize(type, value, location); end

  # source://yarp//../../yarp/lib/yarp.rb#197
  def ==(other); end

  # source://yarp//../../yarp/lib/yarp.rb#179
  def deconstruct_keys(keys); end

  # Returns the value of attribute location.
  #
  # source://yarp//../../yarp/lib/yarp.rb#171
  def location; end

  # source://yarp//../../yarp/lib/yarp.rb#183
  def pretty_print(q); end

  # Returns the value of attribute type.
  #
  # source://yarp//../../yarp/lib/yarp.rb#171
  def type; end

  # Returns the value of attribute value.
  #
  # source://yarp//../../yarp/lib/yarp.rb#171
  def value; end
end

# Represents the use of the literal `true` keyword.
#
#     true
#     ^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5736
class YARP::TrueNode < ::YARP::Node
  # def initialize: (location: Location) -> void
  #
  # @return [TrueNode] a new instance of TrueNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5738
  def initialize(location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5743
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5748
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5748
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5756
  def deconstruct_keys(keys); end
end

# Represents the use of the `undef` keyword.
#
#     undef :foo, :bar, :baz
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5765
class YARP::UndefNode < ::YARP::Node
  # def initialize: (names: Array[Node], keyword_loc: Location, location: Location) -> void
  #
  # @return [UndefNode] a new instance of UndefNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5773
  def initialize(names, keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5780
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5785
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5785
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5793
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5798
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5770
  def keyword_loc; end

  # attr_reader names: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5767
  def names; end
end

# Represents the use of the `unless` keyword, either in the block form or the modifier form.
#
#     bar unless foo
#     ^^^^^^^^^^^^^^
#
#     unless foo then bar end
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5810
class YARP::UnlessNode < ::YARP::Node
  # def initialize: (keyword_loc: Location, predicate: Node, statements: Node?, consequent: Node?, end_keyword_loc: Location?, location: Location) -> void
  #
  # @return [UnlessNode] a new instance of UnlessNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5827
  def initialize(keyword_loc, predicate, statements, consequent, end_keyword_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5837
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5842
  def child_nodes; end

  # attr_reader consequent: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5821
  def consequent; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5842
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5850
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5860
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5824
  def end_keyword_loc; end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5855
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5812
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5815
  def predicate; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5818
  def statements; end
end

# Represents the use of the `until` keyword, either in the block form or the modifier form.
#
#     bar until foo
#     ^^^^^^^^^^^^^
#
#     until foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5872
class YARP::UntilNode < ::YARP::Node
  # def initialize: (keyword_loc: Location, predicate: Node, statements: Node?, location: Location) -> void
  #
  # @return [UntilNode] a new instance of UntilNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5883
  def initialize(keyword_loc, predicate, statements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5891
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5896
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5896
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5904
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5909
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5874
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5877
  def predicate; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5880
  def statements; end
end

YARP::VERSION = T.let(T.unsafe(nil), String)

# source://yarp//../../yarp/lib/yarp/node.rb#6183
class YARP::Visitor < ::YARP::BasicVisitor
  # Visit a AliasNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_alias_node(node); end

  # Visit a AlternationPatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_and_node(node); end

  # Visit a ArgumentsNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_arguments_node(node); end

  # Visit a ArrayNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_block_argument_node(node); end

  # Visit a BlockNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_block_node(node); end

  # Visit a BlockParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_break_node(node); end

  # Visit a CallNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_call_node(node); end

  # Visit a CallOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_call_operator_and_write_node(node); end

  # Visit a CallOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_call_operator_or_write_node(node); end

  # Visit a CallOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_call_operator_write_node(node); end

  # Visit a CapturePatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_capture_pattern_node(node); end

  # Visit a CaseNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_case_node(node); end

  # Visit a ClassNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_class_node(node); end

  # Visit a ClassVariableOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_class_variable_operator_and_write_node(node); end

  # Visit a ClassVariableOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_class_variable_operator_or_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_class_variable_write_node(node); end

  # Visit a ConstantOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_constant_operator_and_write_node(node); end

  # Visit a ConstantOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_constant_operator_or_write_node(node); end

  # Visit a ConstantOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantPathNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_constant_path_operator_and_write_node(node); end

  # Visit a ConstantPathOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_constant_path_operator_or_write_node(node); end

  # Visit a ConstantPathOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_constant_read_node(node); end

  # Visit a DefNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_def_node(node); end

  # Visit a DefinedNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_defined_node(node); end

  # Visit a ElseNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_ensure_node(node); end

  # Visit a FalseNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_false_node(node); end

  # Visit a FindPatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_find_pattern_node(node); end

  # Visit a FloatNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_float_node(node); end

  # Visit a ForNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_global_variable_operator_and_write_node(node); end

  # Visit a GlobalVariableOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_global_variable_operator_or_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_hash_node(node); end

  # Visit a HashPatternNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_if_node(node); end

  # Visit a ImaginaryNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_imaginary_node(node); end

  # Visit a InNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_in_node(node); end

  # Visit a InstanceVariableOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_instance_variable_operator_and_write_node(node); end

  # Visit a InstanceVariableOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_instance_variable_operator_or_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_integer_node(node); end

  # Visit a InterpolatedRegularExpressionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_interpolated_x_string_node(node); end

  # Visit a KeywordHashNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_keyword_hash_node(node); end

  # Visit a KeywordParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_keyword_parameter_node(node); end

  # Visit a KeywordRestParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_lambda_node(node); end

  # Visit a LocalVariableOperatorAndWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_local_variable_operator_and_write_node(node); end

  # Visit a LocalVariableOperatorOrWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_local_variable_operator_or_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_local_variable_write_node(node); end

  # Visit a MatchPredicateNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_match_required_node(node); end

  # Visit a MissingNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_missing_node(node); end

  # Visit a ModuleNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_module_node(node); end

  # Visit a MultiWriteNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_multi_write_node(node); end

  # Visit a NextNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_next_node(node); end

  # Visit a NilNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedReferenceReadNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_or_node(node); end

  # Visit a ParametersNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_program_node(node); end

  # Visit a RangeNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_range_node(node); end

  # Visit a RationalNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_rational_node(node); end

  # Visit a RedoNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_regular_expression_node(node); end

  # Visit a RequiredDestructuredParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_required_destructured_parameter_node(node); end

  # Visit a RequiredParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_retry_node(node); end

  # Visit a ReturnNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_return_node(node); end

  # Visit a SelfNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_self_node(node); end

  # Visit a SingletonClassNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_source_line_node(node); end

  # Visit a SplatNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_splat_node(node); end

  # Visit a StatementsNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_statements_node(node); end

  # Visit a StringConcatNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_string_concat_node(node); end

  # Visit a StringNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_string_node(node); end

  # Visit a SuperNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_super_node(node); end

  # Visit a SymbolNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_symbol_node(node); end

  # Visit a TrueNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_true_node(node); end

  # Visit a UndefNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_undef_node(node); end

  # Visit a UnlessNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_unless_node(node); end

  # Visit a UntilNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_until_node(node); end

  # Visit a WhenNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_when_node(node); end

  # Visit a WhileNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_while_node(node); end

  # Visit a XStringNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_x_string_node(node); end

  # Visit a YieldNode node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6178
  def visit_yield_node(node); end
end

# case true
# when true
# ^^^^^^^^^
# end
#
# source://yarp//../../yarp/lib/yarp/node.rb#5918
class YARP::WhenNode < ::YARP::Node
  # def initialize: (keyword_loc: Location, conditions: Array[Node], statements: Node?, location: Location) -> void
  #
  # @return [WhenNode] a new instance of WhenNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5929
  def initialize(keyword_loc, conditions, statements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5937
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5942
  def child_nodes; end

  # attr_reader conditions: Array[Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5923
  def conditions; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5942
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5950
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5955
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5920
  def keyword_loc; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5926
  def statements; end
end

# Represents the use of the `while` keyword, either in the block form or the modifier form.
#
#     bar while foo
#     ^^^^^^^^^^^^^
#
#     while foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#5967
class YARP::WhileNode < ::YARP::Node
  # def initialize: (keyword_loc: Location, predicate: Node, statements: Node?, location: Location) -> void
  #
  # @return [WhileNode] a new instance of WhileNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5978
  def initialize(keyword_loc, predicate, statements, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5986
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5991
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5991
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5999
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6004
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5969
  def keyword_loc; end

  # attr_reader predicate: Node
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5972
  def predicate; end

  # attr_reader statements: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#5975
  def statements; end
end

# Represents an xstring literal with no interpolation.
#
#     `foo`
#     ^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#6013
class YARP::XStringNode < ::YARP::Node
  # def initialize: (opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String, location: Location) -> void
  #
  # @return [XStringNode] a new instance of XStringNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6027
  def initialize(opening_loc, content_loc, closing_loc, unescaped, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6036
  def accept(visitor); end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6041
  def child_nodes; end

  # def closing: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6064
  def closing; end

  # attr_reader closing_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6021
  def closing_loc; end

  # def content: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6059
  def content; end

  # attr_reader content_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6018
  def content_loc; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6041
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6049
  def deconstruct_keys(keys); end

  # def opening: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6054
  def opening; end

  # attr_reader opening_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6015
  def opening_loc; end

  # attr_reader unescaped: String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6024
  def unescaped; end
end

# Represents the use of the `yield` keyword.
#
#     yield 1
#     ^^^^^^^
#
# source://yarp//../../yarp/lib/yarp/node.rb#6073
class YARP::YieldNode < ::YARP::Node
  # def initialize: (keyword_loc: Location, lparen_loc: Location?, arguments: Node?, rparen_loc: Location?, location: Location) -> void
  #
  # @return [YieldNode] a new instance of YieldNode
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6087
  def initialize(keyword_loc, lparen_loc, arguments, rparen_loc, location); end

  # def accept: (visitor: Visitor) -> void
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6096
  def accept(visitor); end

  # attr_reader arguments: Node?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6081
  def arguments; end

  # def child_nodes: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6101
  def child_nodes; end

  # def child_nodes: () -> Array[nil | Node]
  # def deconstruct: () -> Array[nil | Node]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6101
  def deconstruct; end

  # def deconstruct_keys: (keys: Array[Symbol]) -> Hash[Symbol, nil | Node | Array[Node] | String | Token | Array[Token] | Location]
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6109
  def deconstruct_keys(keys); end

  # def keyword: () -> String
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6114
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6075
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6119
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6078
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6124
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # source://yarp//../../yarp/lib/yarp/node.rb#6084
  def rparen_loc; end
end
